---
layout:     post                    # 使用的布局（不需要改）
title:      leetcode每日一题               # 标题 
subtitle:    #副标题
date:       2020-10-18              # 时间
author:     serenity                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - leetcode
    - 算法
---

## 给今年底/明年打工面试做点准备

### 10.18 leetcode19 删除链表的倒数第N个节点 medium

#### tag：双指针

#### 题目

```markdown
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
说明：

给定的 n 保证是有效的。

进阶：

你能尝试使用一趟扫描实现吗？
```

#### 思路

双指针，fast先走n步，这样fast到尾部时slow指向倒数第n个，注意判断下特例

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        int len=1;
        ListNode* fast=head;
        ListNode* slow=head;
        for(int i=0;i<n-1;i++){
            fast=fast->next;
        }
        if(fast->next==nullptr&&fast==head){
            return nullptr;
        }
        else if(fast->next==nullptr){
            fast=head->next;
            head->next=nullptr;
            return fast;
        }
        fast=fast->next;
        while(fast->next!=nullptr){
            slow=slow->next;
            fast=fast->next;
        }
        slow->next=slow->next->next;
        return head;
    }
};
```



### 10.20 leetcode143 重排链表 medium

#### tag：双指针 链表反转

#### 题目

```markdown
给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:

给定链表 1->2->3->4, 重新排列为 1->4->2->3.
示例 2:

给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3
```

#### 思路

先用双指针确定中点（fast速度是slow两倍），再分成两个链表后将后一半反转，两个链表再依次取值

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
 //双指针
class Solution {
public:
    void reorderList(ListNode* head) {
        if(head==nullptr||head->next==nullptr)
            return ;
        ListNode* fast=head;
        ListNode* slow=head;
        //fast速度为slow两倍,slow定位至middle
        while(!(fast->next==nullptr||fast->next->next==nullptr)){
            fast=fast->next->next;
            slow=slow->next;
        }
        fast=head;//存return
        ListNode* middle=slow->next;
        slow->next=nullptr;
        ListNode* temp=nullptr;
        middle=reverse(middle);
        while(head!=nullptr&&middle!=nullptr){
            temp=middle->next;
            middle->next=head->next;
            head->next=middle;
            head=middle->next;
            middle=temp;
        }
        return ;
    }
    ListNode* reverse(ListNode* head){
        ListNode *p1 = NULL;
        ListNode *p2 = head;
        ListNode *p3 = p2;
        
        while(p2){
            p3 = p2->next;
            p2->next = p1;
            p1 = p2;
            p2 = p3;            
        }
        return p1;
    }
};
```

#### 其他思路

不反转后半段，而是使用栈来处理



### 10.21 leetcode925 长按键入 easy

#### tag：双指针 字符串

#### 题目

```markdown
你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。

你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。

 

示例 1：

输入：name = "alex", typed = "aaleex"
输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。
示例 2：

输入：name = "saeed", typed = "ssaaedd"
输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。
示例 3：

输入：name = "leelee", typed = "lleeelee"
输出：true
示例 4：

输入：name = "laiden", typed = "laiden"
输出：true
解释：长按名字中的字符并不是必要的。
 

提示：

name.length <= 1000
typed.length <= 1000
name 和 typed 的字符都是小写字母。
 
```

#### 思路

双指针对应typed和name，typed的每一个char要么匹配name中的一个char，要么和typed前一个相同，否则即为false

```cpp
class Solution {
public:
    bool isLongPressedName(string name, string typed) {
        int i = 0, j = 0;
        while (j < typed.length()) {
            if (i < name.length() && name[i] == typed[j]) {
                i++;
                j++;
            } else if (j > 0 && typed[j] == typed[j - 1]) {
                j++;
            } else {
                return false;
            }
        }
        return i == name.length();
    }
};
```



### 10.22 leetcode763 划分字母区间 medium

#### tag：哈希 贪心

#### 题目

```markdown
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。

 

示例 1：

输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
 

提示：

S的长度在[1, 500]之间。
S只包含小写字母 'a' 到 'z' 。
 
```

#### 思路

先遍历一遍记录所有字母的最后出现的位置（end），使用hash（map）存储。在进行指针遍历时，使用segend记录当前段的终点（每一次前进先更新segend，为max（segend,map[S[I]]）），当i=segend时即即为一个段。

```cpp
class Solution {
public:
    vector<int> partitionLabels(string S) {
        vector<int> res;
        unordered_map<char, int> map;
        for(int i=0;i<S.length();i++){
            map[S[i]]=i;
        }//遍历记录每个字母end
        int segend=map[S[0]];
        int rec=0;
        for(int i=0;i<S.length();i++){
            if(map[S[i]]>segend){
                segend=map[S[i]];
            }
            if(i==segend){
                segend=0;
                res.push_back(i-rec+1);
                rec=i+1;
            }
        }
        if(res.size()==0)
            res.push_back(S.length());
        return res;

    }
};
```



### 10.23 leetcode234 回文链表 easy

#### tag：快慢指针

#### 题目

```markdown
请判断一个链表是否为回文链表。

示例 1:

输入: 1->2
输出: false
示例 2:

输入: 1->2->2->1
输出: true
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
 
```

#### 思路

类似10.20的重排链表那题。先用快慢指针（fast为两倍速）确定中点，后半段反转后再和前半段一一对比。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* fast=head;
        ListNode* slow=head;
        if(fast==nullptr)
            return true;
        while(fast->next!=nullptr&&fast->next->next!=nullptr){
            fast=fast->next->next;
            slow=slow->next;
        }
        ListNode* middle=reverse(slow->next);
        while(head!=nullptr&&middle!=nullptr){
            if(head->val!=middle->val)
                return false;
            head=head->next;
            middle=middle->next;
        }
        return true;
    }
    ListNode* reverse(ListNode* head){
        ListNode *p1 = NULL;
        ListNode *p2 = head;
        ListNode *p3 = p2;
        
        while(p2){
            p3 = p2->next;
            p2->next = p1;
            p1 = p2;
            p2 = p3;            
        }
        return p1;
    }
};
```



### 11.12 leetcode922 按奇偶排序数组II easy

#### tag：数组

#### 题目

```markdown
给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。

对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。

你可以返回任何满足上述条件的数组作为答案。

 

示例：

输入：[4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
 

提示：

2 <= A.length <= 20000
A.length % 2 == 0
0 <= A[i] <= 100
 
```

#### 思路

i：easy，两个向量扫描一遍，当同时出现奇数&偶数不配对的情况时，swap

ii：还可以考虑空间换时间，再开一个res数组，依次往里面填，免去交换过程

```cpp
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& A) {
        int i=0,j=1;
        int temp=0;
        while(i<A.size()&&j<A.size()){
            if(A.at(i)%2!=0&&A.at(j)!=1){
                temp=A.at(i);
                A.at(i)=A.at(j);
                A.at(j)=temp;
            }
            if(A.at(i)%2==0)
                i+=2;
            if(A.at(j)%2==1)
                j+=2; 
        }
        return A;
    }
};
```





### 11.13 leetcode328 奇偶链表 medium

#### tag：双指针+固定指针

#### 题目

```markdown
给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

示例 1:

输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
示例 2:

输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
说明:

应当保持奇数节点和偶数节点的相对顺序。
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。
 
```

#### 思路

感觉挺简单的，一个指针指向奇数，一个指向偶数，交替更换next，最后奇数指针指向固定的偶数开头

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        ListNode* slow=head;
        if(head==nullptr||head->next==nullptr)
            return head;
        ListNode* fast=head->next;
        ListNode* sec=fast;
        while(fast!=nullptr&&fast->next!=nullptr){
            slow->next=fast->next;
            slow=slow->next;
            fast->next=slow->next;
            fast=fast->next;
        }
        slow->next=sec;
        if (fast!=nullptr)
            fast->next=nullptr;
        return head;
    }
};
```

