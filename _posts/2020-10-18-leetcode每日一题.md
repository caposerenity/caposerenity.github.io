---
layout:     post                    # 使用的布局（不需要改）
title:      leetcode每日一题               # 标题 
subtitle:    #副标题
date:       2020-10-18              # 时间
author:     serenity                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - leetcode
    - 算法
---

## 给今年底/明年打工面试做点准备

### 10.18 leetcode19 删除链表的倒数第N个节点 medium

#### tag：双指针

#### 题目

```markdown
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
说明：

给定的 n 保证是有效的。

进阶：

你能尝试使用一趟扫描实现吗？
```

#### 思路

双指针，fast先走n步，这样fast到尾部时slow指向倒数第n个，注意判断下特例

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        int len=1;
        ListNode* fast=head;
        ListNode* slow=head;
        for(int i=0;i<n-1;i++){
            fast=fast->next;
        }
        if(fast->next==nullptr&&fast==head){
            return nullptr;
        }
        else if(fast->next==nullptr){
            fast=head->next;
            head->next=nullptr;
            return fast;
        }
        fast=fast->next;
        while(fast->next!=nullptr){
            slow=slow->next;
            fast=fast->next;
        }
        slow->next=slow->next->next;
        return head;
    }
};
```



### 10.20 leetcode143 重排链表 medium

#### tag：双指针 链表反转

#### 题目

```markdown
给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:

给定链表 1->2->3->4, 重新排列为 1->4->2->3.
示例 2:

给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3
```

#### 思路

先用双指针确定中点（fast速度是slow两倍），再分成两个链表后将后一半反转，两个链表再依次取值

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
 //双指针
class Solution {
public:
    void reorderList(ListNode* head) {
        if(head==nullptr||head->next==nullptr)
            return ;
        ListNode* fast=head;
        ListNode* slow=head;
        //fast速度为slow两倍,slow定位至middle
        while(!(fast->next==nullptr||fast->next->next==nullptr)){
            fast=fast->next->next;
            slow=slow->next;
        }
        fast=head;//存return
        ListNode* middle=slow->next;
        slow->next=nullptr;
        ListNode* temp=nullptr;
        middle=reverse(middle);
        while(head!=nullptr&&middle!=nullptr){
            temp=middle->next;
            middle->next=head->next;
            head->next=middle;
            head=middle->next;
            middle=temp;
        }
        return ;
    }
    ListNode* reverse(ListNode* head){
        ListNode *p1 = NULL;
        ListNode *p2 = head;
        ListNode *p3 = p2;
        
        while(p2){
            p3 = p2->next;
            p2->next = p1;
            p1 = p2;
            p2 = p3;            
        }
        return p1;
    }
};
```

#### 其他思路

不反转后半段，而是使用栈来处理



### 10.21 leetcode925 长按键入 easy

#### tag：双指针 字符串

#### 题目

```markdown
你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。

你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。

 

示例 1：

输入：name = "alex", typed = "aaleex"
输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。
示例 2：

输入：name = "saeed", typed = "ssaaedd"
输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。
示例 3：

输入：name = "leelee", typed = "lleeelee"
输出：true
示例 4：

输入：name = "laiden", typed = "laiden"
输出：true
解释：长按名字中的字符并不是必要的。
 

提示：

name.length <= 1000
typed.length <= 1000
name 和 typed 的字符都是小写字母。
 
```

#### 思路

双指针对应typed和name，typed的每一个char要么匹配name中的一个char，要么和typed前一个相同，否则即为false

```cpp
class Solution {
public:
    bool isLongPressedName(string name, string typed) {
        int i = 0, j = 0;
        while (j < typed.length()) {
            if (i < name.length() && name[i] == typed[j]) {
                i++;
                j++;
            } else if (j > 0 && typed[j] == typed[j - 1]) {
                j++;
            } else {
                return false;
            }
        }
        return i == name.length();
    }
};
```



### 10.22 leetcode763 划分字母区间 medium

#### tag：哈希 贪心

#### 题目

```markdown
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。

 

示例 1：

输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
 

提示：

S的长度在[1, 500]之间。
S只包含小写字母 'a' 到 'z' 。
 
```

#### 思路

先遍历一遍记录所有字母的最后出现的位置（end），使用hash（map）存储。在进行指针遍历时，使用segend记录当前段的终点（每一次前进先更新segend，为max（segend,map[S[I]]）），当i=segend时即即为一个段。

```cpp
class Solution {
public:
    vector<int> partitionLabels(string S) {
        vector<int> res;
        unordered_map<char, int> map;
        for(int i=0;i<S.length();i++){
            map[S[i]]=i;
        }//遍历记录每个字母end
        int segend=map[S[0]];
        int rec=0;
        for(int i=0;i<S.length();i++){
            if(map[S[i]]>segend){
                segend=map[S[i]];
            }
            if(i==segend){
                segend=0;
                res.push_back(i-rec+1);
                rec=i+1;
            }
        }
        if(res.size()==0)
            res.push_back(S.length());
        return res;

    }
};
```



### 10.23 leetcode234 回文链表 easy

#### tag：快慢指针

#### 题目

```markdown
请判断一个链表是否为回文链表。

示例 1:

输入: 1->2
输出: false
示例 2:

输入: 1->2->2->1
输出: true
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
 
```

#### 思路

类似10.20的重排链表那题。先用快慢指针（fast为两倍速）确定中点，后半段反转后再和前半段一一对比。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* fast=head;
        ListNode* slow=head;
        if(fast==nullptr)
            return true;
        while(fast->next!=nullptr&&fast->next->next!=nullptr){
            fast=fast->next->next;
            slow=slow->next;
        }
        ListNode* middle=reverse(slow->next);
        while(head!=nullptr&&middle!=nullptr){
            if(head->val!=middle->val)
                return false;
            head=head->next;
            middle=middle->next;
        }
        return true;
    }
    ListNode* reverse(ListNode* head){
        ListNode *p1 = NULL;
        ListNode *p2 = head;
        ListNode *p3 = p2;
        
        while(p2){
            p3 = p2->next;
            p2->next = p1;
            p1 = p2;
            p2 = p3;            
        }
        return p1;
    }
};
```





### 11.9 leetcode973 最接近原点的K个点 medium

#### tag：堆 队列 hash/快排

#### 题目

```markdown
我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。

（这里，平面上两点之间的距离是欧几里德距离。）

你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。

 

示例 1：

输入：points = [[1,3],[-2,2]], K = 1
输出：[[-2,2]]
解释： 
(1, 3) 和原点之间的距离为 sqrt(10)，
(-2, 2) 和原点之间的距离为 sqrt(8)，
由于 sqrt(8) < sqrt(10)，(-2, 2) 离原点更近。
我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。
示例 2：

输入：points = [[3,3],[5,-1],[-2,4]], K = 2
输出：[[3,3],[-2,4]]
（答案 [[-2,4],[3,3]] 也会被接受。）
```

#### 思路

一开始想通过维护一个大小为k的队列，并用hash减少平方值运算次数，对队列内插入时进行排序，但超时了 【时间复杂度O（nk）】

修改后使用大顶堆维护队列,（cpp的优先队列默认是一个大顶堆）【时间复杂度O（nlogk）】

```cpp
//初始解法
class Solution {
public:
    bool compare(vector<int> a,vector<int> b){
        return (a.at(0)*a.at(0)+a.at(1)*a.at(1))<(b.at(0)*b.at(0)+b.at(1)*b.at(1));
    }
    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {
        vector<pair<int, vector<int>>> res;
        for(int i=0;i<points.size();i++){
            int x=points[i][0],y=points[i][1];
            pair<int,vector<int>> p(x*x+y*y,points[i]);
            if(res.size()>=K){
                if(p.first<res.at(K-1).first){
                    res.pop_back();
                }
                else
                    continue;
            }
                int pos=0;
                if(res.size()==0){
                    res.push_back(p);
                    continue;
                }
                while(pos<res.size()){
                    if(p.first<res.at(pos).first){
                        vector<pair<int, vector<int>>>::iterator iter=res.begin()+pos;
                        res.insert(iter,p);
                        break;
                    }
                    pos++;
                }
                if(pos==res.size())
                    res.push_back(p);
            }
            vector<vector<int>> result(K);
            for (int i = 0; i < K; i++) {
                result[i] = res[i].second;
            }
            return result;
        }

};
//使用大顶堆
class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {
        priority_queue<pair<int, vector<int>>, vector<pair<int, vector<int>>>> res;
        for(int i=0;i<points.size();i++){
            int x=points[i][0],y=points[i][1];
            pair<int,vector<int>> p(x*x+y*y,points[i]);
            res.push(p);
            if(res.size()>K){
                res.pop();
            }
        }
            vector<vector<int>> result(K); // 把队列里元素放入数组
            for (int i = 0; i < K; i++) {
                result[i] = res.top().second;
                res.pop();
            }
            return result;
        }

};
```



### 11.10 leetcode31 下一个排列 medium

#### tag：数组

#### 题目

```markdown
实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

示例 1：

输入：nums = [1,2,3]
输出：[1,3,2]
示例 2：

输入：nums = [3,2,1]
输出：[1,2,3]
示例 3：

输入：nums = [1,1,5]
输出：[1,5,1]
示例 4：

输入：nums = [1]
输出：[1]
 

提示：

1 <= nums.length <= 100
0 <= nums[i] <= 100
```

#### 思路

从后向前遍历，若出现nums[i]>nums[i-1],则说明存在更大的字典排序，取i-1之后的比nums[i-1]大的数字中最小的一个与nums[i-1]交换，再从小到大排序nums[i]及之后的。若始终没有nums[i]>nums[i-1],则已经是字典序最大的情况，则直接整个进行排序

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        bool biggest=true;
        for(int i=nums.size()-1;i>0;i--){
            if(nums.at(i)>nums.at(i-1)){
                int swap=i;
                int temp=0;
                for(int j=i;j<nums.size();j++){
                    if(nums.at(j)<nums.at(swap)&&nums.at(j)>nums.at(i-1))
                        swap=j;    
                }
                temp=nums.at(i-1);
                nums.at(i-1)=nums.at(swap);
                nums.at(swap)=temp;
                sort(nums,i);
                biggest=false;
                break;
            }
        }
        if(biggest)
            sort(nums,0);
    
    }
    void sort(vector<int>& nums,int start){
        for(int i=start;i<nums.size()-1;i++){
            int min=i;
            int temp=0;
            for(int j=i+1;j<nums.size();j++){
                if(nums.at(j)<nums.at(min))
                    min=j;
            }
            temp=nums.at(i);
            nums.at(i)=nums.at(min);
            nums.at(min)=temp;
        }
    }
};
```



### 11.12 leetcode922 按奇偶排序数组II easy

#### tag：数组

#### 题目

```markdown
给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。

对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。

你可以返回任何满足上述条件的数组作为答案。

 

示例：

输入：[4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
 

提示：

2 <= A.length <= 20000
A.length % 2 == 0
0 <= A[i] <= 100
 
```

#### 思路

i：easy，两个向量扫描一遍，当同时出现奇数&偶数不配对的情况时，swap

ii：还可以考虑空间换时间，再开一个res数组，依次往里面填，免去交换过程

```cpp
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& A) {
        int i=0,j=1;
        int temp=0;
        while(i<A.size()&&j<A.size()){
            if(A.at(i)%2!=0&&A.at(j)!=1){
                temp=A.at(i);
                A.at(i)=A.at(j);
                A.at(j)=temp;
            }
            if(A.at(i)%2==0)
                i+=2;
            if(A.at(j)%2==1)
                j+=2; 
        }
        return A;
    }
};
```



### 11.13 leetcode328 奇偶链表 medium

#### tag：双指针+固定指针

#### 题目

```markdown
给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

示例 1:

输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
示例 2:

输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
说明:

应当保持奇数节点和偶数节点的相对顺序。
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。
 
```

#### 思路

感觉挺简单的，一个指针指向奇数，一个指向偶数，交替更换next，最后奇数指针指向固定的偶数开头

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        ListNode* slow=head;
        if(head==nullptr||head->next==nullptr)
            return head;
        ListNode* fast=head->next;
        ListNode* sec=fast;
        while(fast!=nullptr&&fast->next!=nullptr){
            slow->next=fast->next;
            slow=slow->next;
            fast->next=slow->next;
            fast=fast->next;
        }
        slow->next=sec;
        if (fast!=nullptr)
            fast->next=nullptr;
        return head;
    }
};
```



### 1.27 leetcode25 K个一组翻转链表 hard

#### tag 链表 模拟 高频

#### 题目

```
给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

 

示例：

给你这个链表：1->2->3->4->5

当 k = 2 时，应当返回: 2->1->4->3->5

当 k = 3 时，应当返回: 3->2->1->4->5

 

说明：

你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
```

#### 思路

本题思路非常清晰，即通过快慢指针依次确定若干组k个节点进行翻转（*链表翻转见leetcode206*），需要注意的是，本题的困难点在于**一个局部链表翻转前后的连接**。

以1->2->3->4->5，k=2时为例

比如翻转3,4时需要将3，4前后先断开，变为1->2  3->4  5，翻转后再连接上，变为1->2->4->3->5

这就要求我们记录原来链表中**3的前一个结点**（代码中的hair）和**4的后一个节点**（代码中的temp），为了使得第一组k个元素也可以这样操作（同时保证了最终结果的返回值固定为pre->next），我们在链表最前方添加一个节点pre，即变为pre->1->2->3->4->5

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* pre=new ListNode(0,head);
        ListNode* fast=pre;
        ListNode* hair=pre;
        ListNode* temp=nullptr;
        while(1){
            for(int i=0;i<k;i++){
                fast=fast->next;
                if(fast==nullptr)
                    return pre->next;//返回值，最终结果
            }
            temp=fast->next;//temp用来保存断开连接前的后继节点
            fast->next=nullptr;
            hair->next=reverse(head);
            fast=head;//此时head已经从局部链表头部变为尾部
            fast->next=temp;//重新连接链表
            hair=fast;
            head=temp;
        }
        
    }

    ListNode* reverse(ListNode* head){
        ListNode* before=nullptr;
        ListNode* after=nullptr;
        ListNode* tail=head;
        while(head!=nullptr){
            after=head->next;
            head->next=before;
            before=head;
            head=after;
        }
        return before;
    }
};
```

### 1.27 leetcode 3 无重复字符的最长子串 medium

#### tag 滑动窗口

#### 题目

```
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

 

示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
示例 4:

输入: s = ""
```

#### 思路

用滑动窗口解决，使用一个hashmap记录存在的字符，当right的字符已经存在时，更新left位置和hashmap

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.length()==0) return 0;
        int left=0,right=0,len=1,res=1;
        map<char,int> mymap;
        mymap.insert(pair<char,int>(s[0],0));
        while(1){
            if(right<s.length()-1) right++;
            else return res;
            if(mymap.find(s[right])==mymap.end()){
                len++;
                mymap.insert(pair<char,int>(s[right],right))
            }else {
				int temp = mymap[s[right]] + 1;
				for (int i = left; i < mymap[s[right]]; i++) {
					mymap.erase(s[i]);
				}
                //很奇怪，这里循环中如果将原先重复字符的map记录也删掉的话，跳出循环后该记录又会自动加上
				mymap[s[right]] = right;
				left = temp;
				len = right - left + 1;
			}
            if(len>res) res=len;
        }
    }
};
```



### 1.29 leetcode 15 三数之和 medium

#### tag 双指针

#### 题目描述

```
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

 

示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
示例 2：

输入：nums = []
输出：[]
示例 3：

输入：nums = [0]
输出：[]
 

提示：

0 <= nums.length <= 3000
-10^5 <= nums[i] <= 10^5
```

#### 思路

暴力解法的时间复杂度为O（N^3），我们对此进行的优化为先进行排序，再根据确定的第一个指针来判断此情况下p2和p3可能的取值，由于需要a+b+c=0，a确定的情况下，b越大则c越小，所以我们使用双指针方法，b从p1+1位置开始向后遍历，c从尾部向前遍历，相遇则对于这个a的值结束。

另外一个需要注意的点是元组不可相同，因此我们遇到和先前一个值相同的情况直接跳过（这也是为什么我们锚定p1而不是p2，因为对于-4，-1，-1，0，1，2这样的情况而言，锚定p1时p2，p3的取值情况会被后续完整包括，，而如果锚定p2则不能，如上述例子中，锚定p2的话，如果也采用相同就跳过的方式，则会漏掉-1，-1，2的组合）

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
       vector<vector<int>> res;
		if (nums.size() < 3) return res;
		sort(nums.begin(), nums.end());
		int p1 = 0, p3 = nums.size() - 1, p2,sum;
		for (p1 = 0; p1 < nums.size()-2; p1++) {
			p2 = p1+1, p3 = nums.size() - 1;
			if (p1 != 0 && nums[p1] == nums[p1 - 1]) continue;
			while (p2 != p3) {
				sum = nums[p1] + nums[p2] + nums[p3];
				if (sum == 0) {
					vector<int> rec = { nums[p1], nums[p2], nums[p3] };
					res.push_back(rec);
					if (p2 < p3) {
						p2++;
						while (nums[p2] == nums[p2 - 1] && p2 < p3) p2++;
					}
					else { break; }
				}
				else if (sum < 0) {
					p2++;
					while (nums[p2] == nums[p2 - 1]&&p2<p3) p2++;
				}
				else {
					p3--;
					while (nums[p3] == nums[p3 + 1] && p3 > p2) p3--;
				}
			}
		}
		return res;
        
    }
};
```

### 3.1 leetcode 103 二叉树的锯齿形层序遍历 medium

#### tag BFS

#### 题目描述

```
给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层序遍历如下：

[
  [3],
  [20,9],
  [15,7]
]
```

#### 思路

一开始想的是BFS+对每一层交替使用栈和队列，后来发现不用这么麻烦，bfs的时候对于一层的结果暂存时进行一下判断，若是需要逆转就reverse后再加入res中。

这题需要注意的是，bfs过程中如何按层存储（在开始每一层的遍历前先记录下当前队列的大小）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<int>t;
        queue<TreeNode*> store;
        bool rev=false;
        vector<vector<int>> res;
        store.push(root);
        while(store.size()!=0){
            int count=store.size();
            for(int i=0;i<count;i++){
                root=store.front();
                store.pop();
                if(root!=NULL){
                    t.push_back(root->val);
                    store.push(root->left);
                    store.push(root->right);
                }
            }
            if(rev){
                reverse(t.begin(),t.end());
            }
            if(t.size()!=0)
                res.push_back(t);
            t.clear();
            rev=!rev;
        }
        return res;
    }
};
```

### 3.1 leetcode 121 买卖股票的最佳时机 medium

#### tag 动态规划

#### 题目描述

```
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

 

示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 

提示：

1 <= prices.length <= 105
0 <= prices[i] <= 104
```

#### 思路

一次遍历，p为指针，同时用mins记录p之前的最小值

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res=0;
        int p=0,mins=prices[0];
        while(p<prices.size()){
            mins=min(prices[p],mins);
            res=max(res,prices[p]-mins);
            p++;
        }

        return res;
    }
};
```

### 3.4 leetcode 146 LRU缓存机制 medium

#### tag 双向链表 hash

#### 题目描述

```
运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。
实现 LRUCache 类：

LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。
 

进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？

 

示例：

输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

#### 思路

由于要求在O(1)内完成，很显然要用hash的来存取。但是hash无法实现有序存储（即根据访问时间进行lru），这里又需要我们用一个list或者vector来存储，但vector这里数组的删除复杂度为O(N)，因此我们选用双向链表（双向是为了便于添加删除），链表的节点存储key和val（链表也存储key是为了便于在map中删除时根据head节点获取要删除的key）。

另一个trick是使用链表时，为了减少边界情况的if判断，可以使用一个head和tail节点

```cpp
struct Node {
	int key, val;
	Node *prev;
	Node *next;
	Node(int key, int x) :key(key), val(x), prev(NULL), next(NULL) {}
};

class LRUCache {
public:
	LRUCache(int capacity) {
		cap = capacity;
	}

	int get(int key) {
		if (m.find(key) != m.end()) {
			p = m.at(key);
			p->prev->next = p->next;
			p->next->prev = p->prev;

			p->next = tail;
			p->prev = tail->prev;
			tail->prev->next = p;
			tail->prev = p;

			return m.at(key)->val;
		}
		else {
			return -1;
		}
	}

	void put(int key, int value) {
		if (m.size() == 0) {
			p = new Node(key, value);
			m.insert(pair<int, Node*>(key, p));
			head = new Node(-1, -1);;
			tail = new Node(-1, -1);;
			head->next =p; 
			tail->prev = p;
            p->next=tail;
            p->prev=head;
		}
		else if( m.find(key) != m.end()) {
            //将其移动至链表尾部并修改value
				p = m.at(key);
				p->val = value;
				p->prev->next = p->next;
				p->next->prev = p->prev;

				p->next = tail;
				p->prev = tail->prev;
				tail->prev->next = p;
				tail->prev = p;
			}
            else{
                if (m.size() < cap) {
                    p = new Node(key, value);
                    p->next = tail;
                    p->prev = tail->prev;
                    tail->prev->next = p;
                    tail->prev = p;
                    m.insert(pair<int, Node*>(key, p));
                }
		else {
			//删除头部节点,插入新node至尾部
			p = new Node(key, value);
			m.erase(head->next->key);
			head->next->next->prev = head;
			head->next = head->next->next;
			p->next = tail;
			p->prev = tail->prev;
			tail->prev->next = p;
			tail->prev = p;
			m.insert(pair<int, Node*>(key, p));
		}
        }
	}
private:
	int cap;
	Node* head = nullptr;
	Node* tail = nullptr;
	Node* p = nullptr;
	vector<int> cache;
	unordered_map<int, Node*> m;

};
/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

### 3.4 leetcode 105 从前序和中序构建二叉树 medium

#### tag 树 递归

#### 题目描述

```
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7

```

#### 思路

递归题，模拟大脑内构建这棵二叉树的过程

先获取前序中的[0]作为root，在中序中定位后，中序[index]左侧为左子树，右侧为右子树，递归。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size()==0){
            return NULL;
        }else{
            TreeNode* root=new TreeNode(preorder[0]);
            vector<int>::iterator result=find(inorder.begin(),inorder.end(),preorder[0]             );
            int index=distance(inorder.begin(), result);
            vector<int>a(preorder.begin()+1,preorder.begin()+1+index);
            vector<int>b(inorder.begin(),inorder.begin()+index);
            root->left=buildTree(a,b);
            vector<int>c(preorder.begin()+1+index,preorder.end());
            vector<int>d(inorder.begin()+index+1,inorder.end());
            root->right=buildTree(c,d);
            return root;
        }   
    }
};
```

### 3.4 leetcode 199 二叉树的右视图 medium

#### tag BFS

#### 题目描述

```
给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---

```

#### 思路

和lc103 二叉树锯齿状遍历很像

这题需要注意的是，bfs过程中如何按层存储（在开始每一层的遍历前先记录下当前队列的大小）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int>res;
        queue<TreeNode*> q;
        q.push(root);
        if(root==NULL||q.size()==0)
            return res;
        while(q.size()>0){
            int size=q.size();
            for(int i=0;i<size;i++){
                TreeNode* temp=q.front();
                q.pop();
                if(i==size-1){
                    res.push_back(temp->val);
                }
                if(temp->left!=NULL)
                    q.push(temp->left);
                if(temp->right!=NULL)
                    q.push(temp->right);
            }
        }
        return res;
    }
};
```

### 3.4 leetcode 160 相交链表 easy

#### tag 脑筋急转弯

#### 题目描述

```
编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表：



在节点 c1 开始相交。

 

示例 1：



输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
 

示例 2：



输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
 

示例 3：



输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
 

注意：

如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

```

#### 思路

脑筋急转弯题目。。。不知道为啥喜欢考这种

思路是两个链表相加的总长度是一定的，因此两个指针分别从A、B出发，以A->B和B->A两条路径，如果是有交点的，则必然在路径上某点相遇（交点），否则不会相遇。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *p1=headA;
        ListNode *p2=headB;
        int a=0,b=0;
        if(p1!=NULL&&p2!=NULL){
        while(a<2&&b<2){
            if(p1==NULL){
                p1=headB;
                a++;
            }
            if(p2==NULL){
                p2=headA;
                b++;
            }
            if(p1==p2)
                return p1;
            p1=p1->next;
            p2=p2->next;
        }
        }
        return NULL;
    }
};
```

### 3.4 leetcode 54 螺旋矩阵 medium

#### tag 模拟

#### 题目描述

```
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

示例:

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]

```

#### 思路

直接暴力模拟，很像大一的那种题目

标记一下矩阵内已经访问过的地方，根据direction变量来判断移动方位。边界情况下改变移动方向。

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        const int no=-999;
        int m=matrix.size();
        int n=matrix[0].size();
        int direction=0;//0右 1下 2左 3上
        for(int i=0,j=0,count=0;count<m*n;count++){
            res.push_back(matrix[i][j]);
            matrix[i][j]=no;
            switch(direction){
                case 0:
                    if(j==n-1||matrix[i][j+1]==no){
                        direction=1;
                        i++;
                    }
                    else
                        j++;
                    break;
                case 1:
                    if(i==m-1||matrix[i+1][j]==no){
                        direction=2;
                        j--;
                    }
                    else
                        i++;
                    break;
                case 2:
                    if(j==0||matrix[i][j-1]==no){
                        direction=3;
                        i--;
                    }
                    else
                        j--;
                    break;
                case 3:
                    if(i==0||matrix[i-1][j]==no){
                        direction=0;
                        j++;
                    }
                    else
                        i--;
                    break;  
            }
            
        }

        return res;
    }

};
```

### 3.4 leetcode 21 合并两个有序链表 easy

#### tag 链表

#### 题目描述

```
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

示例 1：


输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
示例 2：

输入：l1 = [], l2 = []
输出：[]
示例 3：

输入：l1 = [], l2 = [0]
输出：[0]

提示：
两个链表的节点数目范围是 [0, 50]
-100 <= Node.val <= 100
l1 和 l2 均按 非递减顺序排列
```

#### 思路

简单题……直接加

注意用一下伪头部，减少if判断

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* l=new ListNode(0);
        ListNode* backup=l;
        while(l1!=nullptr&&l2!=nullptr){
            if(l1->val<=l2->val){
                l->next=l1;
                l1=l1->next;
                l=l->next;
            }else{
                l->next=l2;
                l2=l2->next;
                l=l->next;
            }
        }
        if(l1==nullptr){
            l->next=l2;
        }else{
            l->next=l1;
        }

        return backup->next;
    }
};
```

### 3.5 leetcode 42 接雨水 hard

#### tag 双指针

#### 题目描述

```
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

 

示例 1：

输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
示例 2：

输入：height = [4,2,0,3,2,5]
输出：9

```

#### 思路

思路的重点在于想到对于每一列i，它能接的雨水量是由它左侧最高的一列和右侧最高的一列所决定的。

因此，我们先用从左向右和从右向左的两次遍历求出对于每一列i，它的左侧最高一列leftMax和右侧最高一列rightMax。再计算二者中较小值和自身的差值。

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int res=0;
        vector<int> left;
        vector<int> right;
        int n=height.size();
        for(int i=0,leftMax=0;i<n;i++){
            if(leftMax<height[i]){
                leftMax=height[i];
            }
            left.push_back(leftMax);
        }
        for(int i=n-1,rightMax=0;i>=0;i--){
            if(rightMax<height[i]){
                rightMax=height[i];
            }
            right.insert(right.begin(), rightMax);
        }
        for(int i=0;i<n;i++){
            res+=(min(left[i],right[i])-height[i]);
        }
        return res;
    }
};
```

### 3.5 leetcode 69 x的平方根 easy

#### tag 二分查找

#### 题目描述

```
实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:

输入: 4
输出: 2
示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
```

#### 思路

显然暴力解法是从0开始依次尝试满足i\^2<=x且(i+1)\^2>x的解

对于这类查找题显然可以用二分法化简，本题也可以作为二分查找的模板题

```cpp
class Solution {
public:
    int mySqrt(int x) {
        //二分查找
        if(x==0)return 0;
        if(x==1)return 1;
        int max=x,min=0,res=1;
        while(max-min>1){
            res=(min+max)/2;
            if(res*res<=x)
                min=res;            
            else
                max=res;
        }

        return min;
    }
};
```

### 3.5 leetcode 33 搜索旋转排序数组 medium

#### tag 二分查找

#### 题目描述

```
整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。

 

示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
示例 3：

输入：nums = [1], target = 0
输出：-1
 

提示：

1 <= nums.length <= 5000
-10^4 <= nums[i] <= 10^4
nums 中的每个值都 独一无二
nums 肯定会在某个点上旋转
-10^4 <= target <= 10^4

进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？
```

#### 思路

排序+二分的方法无法满足O(log n)的复杂度要求，本题是二分查找的一个变种问题

可以看到，由于只有一个“断层点”。对于原数组，我们将其二分后，必然有一半是排好序的，另一半则可能是乱序的。而对于这个乱序的一半，再次二分后，又得出一半排好序的和另一半可能乱序…

因此，我们可以根据target值是否在排好序的一侧来判断，若在，则对排好序的一侧进行二分查找。若不在，对可能乱序的一侧我们继续进行二分迭代。

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left=0,right=nums.size()-1,m=-1;
        if(right==-1)return -1;
        if(right==0)return nums[0]==target?0:-1;
        while(right>=left){
            m=left+(right-left)/2;
            if(nums[m]==target)return m;
            if(nums[m]<nums[right]){
                //右侧有序
                if(nums[m]<=target&&nums[right]>=target){
                    left=m+1;
                }else{
                    right=m-1;
                }
            }else{
                //左侧有序
                if(nums[m]>=target&&nums[left]<=target){
                    right=m-1;
                }else{
                    left=m+1;
                }
            }
        }
        return -1;
    }
};
```

### 3.5 leetcode 124 二叉树中的最大路径和 hard

#### tag DFS

#### 题目描述

```
径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。

示例 1：
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
示例 2：

输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

#### 思路

对于经过一个节点，我们将其自身的值、左子树的值、右子树的值看成三个部分。

而一个节点在路径中有三种情况：

一种是仅仅使用了它自身的值（如左右子树均为负值）（其实可以看成是第三种的一个特殊情况）

一种是它作为“路径根节点”（如左右子树均为正，形成一条路径来和当前路径和的最大值比较）

一种是它作为更高层次根节点的路径的一部分，最多只能使用它的一条子树。

因此，我们可以从根节点向下递归求每个节点作为“路径根节点”的最大路径，并依次和当前路径和的最大值比较

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int m=-9999;
    int cal(TreeNode* node){
        if(node==NULL) return 0;
        int l=cal(node->left);
        int r=cal(node->right);
        int res=node->val;
        if(l>0)res+=l;
        if(r>0)res+=r;
        if(res>m)m=res;
        if(l>0&&r>0)res-=min(l,r);
        return res;
    }

    int maxPathSum(TreeNode* root) {
        cal(root);
        return m;
    }
};
```

### 3.5 leetcode 155 最小栈 easy

#### tag 数据结构

#### 题目描述

```
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。
 

示例:

输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
 

提示：

pop、top 和 getMin 操作总是在 非空栈 上调用。
```

#### 思路

直接模拟栈就完事了

这题需要注意的是，pop时需要更新栈内的最小值，且这个操作需要在常数时间内完成。因此我们需要存储每次push之后栈内的最小值。我这里采用的方式是每次往栈内push两个数：x和本次操作后栈内最小值。

```cpp
class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {
        //minNum=INT_MAX;
    }
    
    void push(int x) {
        if(stack.size()==0)
            minNum=x;
        if(x<minNum){
            minNum=x;
        }
        stack.push_back(minNum);
        stack.push_back(x);
    }
    
    void pop() {
        stack.pop_back();
        stack.pop_back();
        if(stack.size()>0)
            minNum=stack.at(stack.size()-2);
    }
    
    int top() {
        return stack.back();
    }
    
    int getMin() {
        return minNum;
    }
private:
    int minNum;
    deque<int> stack;
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```

### 3.5 leetcode 236 二叉树的最近公共祖先 medium

#### tag dfs

#### 题目描述

```
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

示例 1：


输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
示例 2：


输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
示例 3：

输入：root = [1,2], p = 1, q = 2
输出：1
 
提示：
树中节点数目在范围 [2, 105] 内。
-109 <= Node.val <= 109
所有 Node.val 互不相同 。
p != q
p 和 q 均存在于给定的二叉树中。
```

#### 思路

一上来就想到了要用递归DFS做，对于每个节点我们判断它是否是p、q的公共祖先时，这取决于它的两个子节点（及其自身）是否p、q的公共祖先。这里为了便于判断，我用计数方式来表示是否为p/q的祖先，即若是p的祖先则+1，若是q的则+2。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> v;
    int dfs(TreeNode* node,TreeNode* p,TreeNode* q){
        if(node==NULL)return 0;
        int res=0;
        if(node==p)res+=1;
        if(node==q)res+=2;
        int l=dfs(node->left,p,q);
        int r=dfs(node->right,p,q);
        res=res+l+r;
        if(res==3)
            v.push_back(node);
        return res;
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        dfs(root,p,q);
        return v.front();
    }
};
```

### 3.5 leetcode 415 字符串相加 easy

#### tag 字符串

#### 题目描述

```
给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

 

提示：

num1 和num2 的长度都小于 5100
num1 和num2 都只包含数字 0-9
num1 和num2 都不包含任何前导零
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式
```

#### 思路

简单题……

```cpp
class Solution {
public:
    string addStrings(string num1, string num2) {
        string res="";
        int len1=num1.length(),len2=num2.length();
        int plus=0;
        reverse(num1.begin(), num1.end());
        reverse(num2.begin(), num2.end());
        if(len1<len2){
            for(int i=0;i<len2-len1;i++){
                num1+="0";
            }
        }else{
            for(int i=0;i<len1-len2;i++){
                num2+="0";
            }
        }
        int l=max(len1,len2);
        for(int i=0;i<l;i++){
            res+=('0'+(num1.at(i)-'0'+num2.at(i)-'0'+plus)%10);
            plus=((num1.at(i)-'0'+num2.at(i)-'0'+plus)/10);
        }
        if(plus!=0)
            res+=('0'+plus);
        reverse(res.begin(), res.end());
        return res;
    }
};
```

### 3.5 leetcode 1 两数之和 easy

#### tag hash

#### 题目描述

```
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。

 

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]
 

提示：

2 <= nums.length <= 103
-109 <= nums[i] <= 109
-109 <= target <= 109
只会存在一个有效答案
```

#### 思路

由于只存在一个答案，所以免去了三数之和中的排序过程。

我们可以直接使用一个hash来存储遍历过程中的<num,index>对，对于遍历到的某个点i，我们检查map中是否有对应的target-nums[i]，若没有则将i也加入map

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        map<int,int>m;
        vector<int>res;
        for(int i=0;i<nums.size();i++){
            if(m.find(target-nums[i])!=m.end()){
                res.push_back(m.at(target-nums[i]));
                res.push_back(i);
                return res;
            }else{
                m.insert(pair<int,int>(nums[i],i));
            }
        }
        return res;
    }
};
```

### 3.5 leetcode 23 合并K个升序链表 hard

#### tag hash

#### 题目描述

```
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

 

示例 1：

输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
示例 2：

输入：lists = []
输出：[]
示例 3：

输入：lists = [[]]
输出：[]
 

提示：

k == lists.length
0 <= k <= 10^4
0 <= lists[i].length <= 500
-10^4 <= lists[i][j] <= 10^4
lists[i] 按 升序 排列
lists[i].length 的总和不超过 10^4
```

#### 思路

看到题目的第一思路就是用k个指针分别指向这k个链表，每次选择val最小的加入到res中，最终这个写法是可行的，就是时间上有点……但好歹过了

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool check(int k,vector<ListNode*>& lists){
        for(int i=0;i<k;i++){
            if(lists[i]!=NULL)
                return true;
        }
        return false;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        int k=lists.size();
        ListNode* res=new ListNode(0);
        ListNode* root=res;
        while(check(k,lists)){
            int value=INT_MAX;
            int index=-1;
            for(int i=0;i<k;i++){
                if(lists[i]!=NULL&&lists[i]->val<value){
                    value=lists[i]->val;
                    root->next=lists[i];
                    index=i;
                }
            }
            lists[index]=lists[index]->next;
            root=root->next;
        }
        return res->next;
    }
};
```

### 3.5 leetcode 41 缺失的第一个整数 hard

#### tag hash 妙

#### 题目描述

```
给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

 

进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？

 

示例 1：

输入：nums = [1,2,0]
输出：3
示例 2：

输入：nums = [3,4,-1,1]
输出：2
示例 3：

输入：nums = [7,8,9,11,12]
输出：1
 

提示：

0 <= nums.length <= 300
-231 <= nums[i] <= 231 - 1
```

#### 思路

如果这题没有空间复杂度O(1)的要求的话，可以直接遍历数组用hash存储数组出现的正整数。之后再从1开始找不在hash中的。

但由于O(1)的复杂度要求，我们只能在原数组上模拟hash的操作。

这里使用了下标提供的信息，即：考虑到没出现的最小正整数只能在1-n+1中取（最多有n个正整数），我们在第一次遍历时发现某个值i在1-n+1范围内时，就将它交换移动到对应的下标i-1处。这样，在第二次遍历的时候，我们就可以直接返回第一个不对应的数，若都对应，则返回n+1。

需要注意的是，交换这种方法可能会对[1,1]这种测试数据产生死循环，因此条件里额外加了一个nums[nums[i]-1]!=nums[i]。

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n=nums.size();
        int i=0;
        while(i<n){
            if(nums[i]>0&&nums[i]<=n&&nums[i]-1!=i&&nums[nums[i]-1]!=nums[i]){
                int t=nums[nums[i]-1];
                nums[nums[i]-1]=nums[i];
                nums[i]=t;
                i--;
            }
            i++;
        }
        for(int i=0;i<n;i++){
            if(nums[i]!=i+1)
                return i+1;
        }
        return n+1;
    }
};
```

### 3.5 leetcode 141 环形链表 easy

#### tag 快慢指针

#### 题目描述

```
给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。

 

进阶：

你能用 O(1)（即，常量）内存解决此问题吗？
```

#### 思路

快慢指针，如果快指针是慢指针速度的两倍，若有环，则最终能相遇，否则两个指针会有至少一个在中途变为NULL

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *fast=head;
        ListNode *slow=head;
        if(head==NULL||head->next==NULL)
            return false;
        while(fast!=NULL&&slow!=NULL){
            slow=slow->next;
            if(fast->next!=NULL)
                fast=fast->next->next;
            else
                return false;
            if(slow==fast)
                return true;
        }
        return false;
    }
};
```

### 3.5 leetcode 20 有效的括号 easy

#### tag 栈

#### 题目描述

```
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
 

示例 1：

输入：s = "()"
输出：true
示例 2：

输入：s = "()[]{}"
输出：true
示例 3：

输入：s = "(]"
输出：false
示例 4：

输入：s = "([)]"
输出：false
示例 5：

输入：s = "{[]}"
输出：true
 

提示：

1 <= s.length <= 104
s 仅由括号 '()[]{}' 组成
```

#### 思路

非常经典的栈的例题，挺简单的

```cpp
class Solution {
public:
    bool isValid(string s) {
        int n=s.length();
        vector<char> q;
        for(int i=0;i<n;i++){
            switch(s[i]){
                case ')':
                    if(q.size()>0&&q.back()=='(')
                        q.pop_back();
                    else
                        return false;
                    break;
                case '}':
                    if(q.size()>0&&q.back()=='{')
                        q.pop_back();
                    else
                        return false;
                    break;
                case ']':
                    if(q.size()>0&&q.back()=='[')
                        q.pop_back();
                    else
                        return false;
                    break;
                default:
                    q.push_back(s[i]);
                    break;
            }
        }
        if(q.size()==0)
            return true;
        else
            return false;
    }
};
```

### 3.5 leetcode 24 两两交换链表中的节点 medium

#### tag 翻转链表

#### 题目描述

```
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 

示例 1：


输入：head = [1,2,3,4]
输出：[2,1,4,3]
示例 2：

输入：head = []
输出：[]
```

#### 思路

本题是k个一组翻转链表的k取2时的特殊情况，注意使用伪头部化简

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head==NULL||head->next==NULL)
            return head;
        ListNode* hair=new ListNode(0);
        hair->next=head;
        ListNode* before=hair;
        ListNode* after=hair;
        while(head!=NULL&&head->next!=NULL){
            after=head->next->next;
            head->next->next=NULL;
            before->next=NULL;
            head=reverse(head);
            before->next=head;
            head->next->next=after;
            before=head->next;
            head=after;
        }
        return hair->next;
    }
    ListNode* reverse(ListNode* head){
        ListNode* temp=head->next;
        head->next=NULL;
        temp->next=head;
        return temp;
    }
};
```

### 3.6 leetcode 98 验证二叉搜索树 medium

#### tag dfs 中序

#### 题目描述

```
给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
示例 1:

输入:
    2
   / \
  1   3
输出: true
示例 2:

输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

#### 思路

思路一：二叉搜索树的中序排列是有序的（递增），所以只需要走一遍中序排列即可

思路二：DFS递归的时候，带上两个参数max和min，分别标识本次递归允许的上限和下限（如递归root的左子树时，设置上限为root->val，下线为INT_MIN）

```cpp
class Solution {
public:
    long lastVal=LONG_MIN;

    bool isValidBST(TreeNode* root) {
        bool l=true;
        if(root->left!=NULL)
            l=isValidBST(root->left);
        bool m=false;
        if(root->val>lastVal){
            lastVal=root->val;
            m=true;
        }
        bool r=true;
        if(root->right!=NULL)
            r=isValidBST(root->right);
        return l&&r&&m;
    }
};
```

### 3.6 leetcode 79 单词搜索 medium

#### tag dfs 回溯算法

#### 题目描述

```
给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

示例:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false
 

提示：

board 和 word 中只包含大写和小写英文字母。
1 <= board.length <= 200
1 <= board[i].length <= 200
1 <= word.length <= 10^3
```

#### 思路

经典的回溯题，用深搜的写法，逻辑上不难理解，即不停的向四个方向找是否满足下一个char，且维护一个访问过的数组visited（可以在原数组上实现）。主要问题还是在于代码实现上。

```cpp
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        int m=board.size(),n=board[0].size();
        int k=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(dfs(board,word,i,j,k)){
                    return true;
                }
            }
        }
        return false;
    }

    bool dfs(vector<vector<char>>& board, string word,int i,int j,int k){
        if(k==0){
            if(board[i][j]!=word[k])return false;
            else{
                board[i][j]='0';
                if(dfs(board,word,i,j,k+1)){
                    return true;
                }else{
                    board[i][j]=word[k];
                    return false;
                }
            }
        }
        else if(k>=word.length()) return true;
        else{
            if(i-1>=0&&board[i-1][j]==word[k]){
                board[i-1][j]='0';
                if(dfs(board,word,i-1,j,k+1)){
                    return true;
                }else{
                    board[i-1][j]=word[k];
                    //return false;
                }
            }
            if(i+1<board.size()&&board[i+1][j]==word[k]){
                board[i+1][j]='0';
                if(dfs(board,word,i+1,j,k+1)){
                    return true;
                }else{
                    board[i+1][j]=word[k];
                    //return false;
                }
            }
            if(j-1>=0&&board[i][j-1]==word[k]){
                board[i][j-1]='0';
                if(dfs(board,word,i,j-1,k+1)){
                    return true;
                }else{
                    board[i][j-1]=word[k];
                    //return false;
                }
            }
            if(j+1<board[0].size()&&board[i][j+1]==word[k]){
                board[i][j+1]='0';
                if(dfs(board,word,i,j+1,k+1)){
                    return true;
                }else{
                    board[i][j+1]=word[k];
                    //return false;
                }
            }
            return false;
        }

    }
};
```

### 3.6 leetcode 46 全排列 medium

#### tag 回溯算法

#### 题目描述

```
给定一个 没有重复 数字的序列，返回其所有可能的全排列。

示例:

输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

#### 思路

这题也是回溯写法，主层循环里依次选取起始的第一个数字，然后在回溯的过程中将已经走过的地方置为INT_MIN

```cpp
class Solution {
public:
    vector<vector<int>>res;
    
    void dfs(vector<int>& nums,vector<int>&temp){
        if(temp.size()==nums.size()) {
            res.push_back(temp);
            return;
        }else{
            for(int i=0;i<nums.size();i++){
                if(nums[i]!=INT_MIN){
                temp.push_back(nums[i]);
                int t=nums[i];
                nums[i]=INT_MIN;
                dfs(nums,temp);
                temp.pop_back();
                nums[i]=t;
                }
            }
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {    
        vector<int> temp;
        for(int i=0;i<nums.size();i++){
            temp.push_back(nums[i]);
            int t=nums[i];
            nums[i]=INT_MIN;
            dfs(nums,temp);
            nums[i]=t;
            temp.pop_back();
        }
        return res;
    }
};
```

### 3.6 leetcode 2 两数相加 medium

#### tag 链表

#### 题目描述

```
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

示例 1：


输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
示例 2：

输入：l1 = [0], l2 = [0]
输出：[0]
示例 3：

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

#### 思路

挺简单的。。注意一下边界情况

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int plus=0;
        ListNode *hair=new ListNode(0);
        hair->next=l1;
        ListNode* t;
        while(l1!=NULL&&l2!=NULL){
            l1->val=l1->val+l2->val+plus;
            plus=l1->val/10;
            l1->val%=10;
            t=l1;
            l1=l1->next;
            l2=l2->next;
        }
        if(l1==NULL){
            l1=l2;
        }
        t->next=l1;
        while(l1!=NULL){
            l1->val+=plus;
            plus=l1->val/10;
            l1->val%=10;
            t=l1;
            l1=l1->next;
        }
        if(plus!=0){
            l1= new ListNode(plus);
            t->next=l1;
        }
        

        return hair->next;
    }
};
```

### 3.6 leetcode 101 对称二叉树 easy

#### tag BFS/DFS

#### 题目描述

```
给定一个二叉树，检查它是否是镜像对称的。

 

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3
 

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3
 

进阶：

你可以运用递归和迭代两种方法解决这个问题吗？
```

#### 思路

两种方法，dfs先左后右和先右后左如果结果一样，则true，否则不对称

bfs则是对每层判断是否对称，注意null

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        deque<TreeNode*>q;
        q.push_back(root);
        while(!q.empty()){
            int size=q.size();
            vector<int>v;
            for(int i=0;i<size;i++){
                if(q.front()!=NULL){
                    q.push_back(q.front()->left);
                    q.push_back(q.front()->right);
                    v.push_back(q.front()->val);
                }else{
                    v.push_back(INT_MIN);
                }
                q.pop_front();
            }
            if(!check(v))return false;
            v.clear();
        }
        return true;
    }
    bool check(vector<int>& v){
        for(int i=0;i<v.size();i++){
            if(v[i]!=v[v.size()-1-i])
                return false;
        }
        return true;
    }
};
```

### 3.6 leetcode 470 用rand7()实现rand10() medium

#### tag 数学

#### 题目描述

```
已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。

不要使用系统的 Math.random() 方法。

 

示例 1:

输入: 1
输出: [7]
示例 2:

输入: 2
输出: [8,4]
示例 3:

输入: 3
输出: [8,1,10]
 

提示:

rand7 已定义。
传入参数: n 表示 rand10 的调用次数。
 

进阶:

rand7()调用次数的 期望值 是多少 ?
你能否尽量少调用 rand7() ?
```

#### 思路

神奇的数学题

本题的核心在于int a=rand7();

​    int b=rand7();

​    res=(a-1)*7+b;

res的这个表达式生成了一个在1-49之间均匀分布的随机数，这样我们只需要在<=40的时候取模即可，若大于40则再生成一次

```cpp
// The rand7() API is already defined for you.
// int rand7();
// @return a random integer in the range 1 to 7

class Solution {
public:
    int rand10() {
    int res;
    while(1){
        int a=rand7();
        int b=rand7();
        res=(a-1)*7+b;
        if(res<=40)
            break;
    }
    return res%10+1;
    }
};
```

### 3.6 leetcode 958 二叉树的完全性检验 medium

#### tag BFS

#### 题目描述

```
给定一个二叉树，确定它是否是一个完全二叉树。

百度百科中对完全二叉树的定义如下：

若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）

 

示例 1：



输入：[1,2,3,4,5,6]
输出：true
解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。
示例 2：



输入：[1,2,3,4,5,null,7]
输出：false
解释：值为 7 的结点没有尽可能靠向左侧。
 

提示：

树中将会有 1 到 100 个结点。
```

#### 思路

很显然是一道bfs，在null节点之后不能再出现非null节点

```cpp
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
    deque<TreeNode*>q;
    q.push_back(root);
    while(!q.empty()){
        int size=q.size();
        vector<TreeNode*>v;
        for(int i=0;i<size;i++){
            if(q.front()!=NULL){
                q.push_back(q.front()->left);
                q.push_back(q.front()->right);
                v.push_back(q.front());
            }else{
                v.push_back(NULL);
            }
            q.pop_front();
        }
        if(q.size()!=2*size&&q.size()!=0){
            if(!check(v))return false;
        }
        v.clear();
    }
    return true;
    }
    bool check(vector<TreeNode*>& v){
        int last=0,first=-1;
        for(int i=0;i<v.size();i++){
            if(v[i]==NULL){
                if(first==-1)
                 first=i;} 
            else{ if(v[i]->left!=NULL||v[i]->right!=NULL)
                return false;
                last=i;
            }
        }
        if(last<first)
        return true;
        else
        return false;
    }
};
```

### 3.7 leetcode 92 反转链表 II medium

#### tag 链表

#### 题目描述

```
反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

示例:

输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```

#### 思路

简化版的k个一组翻转链表，需要注意的是链表断开后重新连接

```cpp
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode* hair=new ListNode(0);
        hair->next=head;
        ListNode* start=hair;
        ListNode* end=hair;
        for(int i=0;i<left-1;i++){
            start=start->next;
        }
        ListNode* before=start;
        start=start->next;
        for(int i=0;i<right;i++){
            end=end->next;
        }
        before->next=NULL;
        ListNode* after=end->next;
        end->next=NULL;
        vector<ListNode*> v=reverse(start);
        before->next=v[0];
        v[1]->next=after;
        return hair->next;
    }
    vector<ListNode*> reverse(ListNode* head){
        ListNode *t,*before,*after;
        before=NULL;
        t=head;
        after=head;
        while(head!=NULL){
            after=after->next;
            head->next=before;
            before=head;
            head=after;
        }
        vector<ListNode*>v;
        v.push_back(before);
        v.push_back(t);
        return v;
    }
};
```

### 3.7 leetcode 102 二叉树的层序遍历 medium

#### tag BFS

#### 题目描述

```
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

 

示例：
二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层序遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
```

#### 思路

简单的BFS

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        deque<TreeNode*>q;
        q.push_back(root);
        vector<vector<int>>res;
        while(!q.empty()){
            int size=q.size();
            vector<int>v;
            for(int i=0;i<size;i++){
                if(q.front()!=NULL){
                    q.push_back(q.front()->left);
                    q.push_back(q.front()->right);
                    v.push_back(q.front()->val);
                }
                q.pop_front();
            }
            if(v.size()!=0)
            res.push_back(v);
        }
        return res;
        }
};
```

### 3.7 leetcode 162 寻找峰值 medium

#### tag 二分查找

#### 题目描述

```
峰值元素是指其值大于左右相邻值的元素。

给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

 

示例 1：

输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
示例 2：

输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
 

提示：

1 <= nums.length <= 1000
-231 <= nums[i] <= 231 - 1
对于所有有效的 i 都有 nums[i] != nums[i + 1]
 

进阶：你可以实现时间复杂度为 O(logN) 的解决方案吗？
```

#### 思路

想不到吧，这题都能二分……

虽然是乱序的，但是，（即nums[mid]<nums[mid+1]时，mid+1~N一定存在峰值） 我的理解是，首先已知 nums[mid+1]>nums[mid]，那么mid+2只有两种可能，一个是大于mid+1，一个是小于mid+1，小于mid+1的情况，那么mid+1就是峰值，大于mid+1的情况，继续向右推，如果一直到数组的末尾都是大于的，那么可以肯定最后一个元素是峰值，因为nums[nums.length]=负无穷

```cpp
class Solution {
public:
int findPeakElement(vector<int>& nums) {
    int left = 0, right = nums.size() - 1;
    for (; left < right; ) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > nums[mid + 1]) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
};
```

### 3.7 leetcode 114 二叉树展开为链表 medium

#### tag dfs，前序

#### 题目描述

```
给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。
 

示例 1：


输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
示例 2：

输入：root = []
输出：[]
示例 3：

输入：root = [0]
输出：[0]
 

提示：

树中结点数在范围 [0, 2000] 内
-100 <= Node.val <= 100
 

进阶：你可以使用原地算法（O(1) 额外空间）展开这棵树吗？
```

#### 思路

前序遍历

```cpp
class Solution {
public:
    TreeNode* t1;
    void flatten(TreeNode* root) {
        if(root==nullptr||(root->left==nullptr&&root->right==nullptr))
            return;
        if(root->left!=nullptr)
            flatten(root->left);
        if(root->right!=nullptr)
            flatten(root->right);
        t1=root->right;
        if(root->left!=nullptr){
            root->right=root->left;
            root->left=nullptr;
            while(root->right->right!=nullptr){
                root=root->right;
            }
            root->right->right=t1;
        }
        
        return;
    }
};
```

### 3.7 leetcode 56 合并区间 medium

#### tag 排序

#### 题目描述

```
以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

 

示例 1：

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2：

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
 

提示：

1 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti <= endi <= 104
```

#### 思路

根据left排序，显然只能相邻的才有可能合并

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if(intervals.size()==0)return intervals;
        sort(intervals.begin(),intervals.end());
        vector<vector<int>> res;
        res.push_back(intervals[0]);
        int n=0;
        for(int i=1;i<intervals.size();i++){
            if(intervals[i][0]<=res[n][1]){
                res[n][1]=max(res[n][1],intervals[i][1]);
            }else{
                res.push_back(intervals[i]);
                n++;
            }
        }
        return res;
    }
};
```

### 3.7 leetcode 39 组合综合 medium

#### tag 回溯 模板

#### 题目描述

```
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
示例 1：

输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
示例 2：

输入：candidates = [2,3,5], target = 8,
所求解集为：
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
 

提示：

1 <= candidates.length <= 30
1 <= candidates[i] <= 200
candidate 中的每个元素都是独一无二的。
1 <= target <= 500
```

#### 思路

非常标准的回溯模板题

需要注意的是，为了防止重复（如[2，2，3]和[2，3，2]）这种，需要一个index来指定从哪里开始遍历

```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<int> record;
        search(candidates,target,record,0);
        return res;
    }
    void search(vector<int>& candidates, int target,vector<int>& record,int index){
        if(target<0)return;
        else if(target==0){
            res.push_back(record);
        }
        else{
            for(int i=index;i<candidates.size();i++){
                record.push_back(candidates[i]);
                search(candidates,target-candidates[i],record,i);
                record.pop_back();
            }
        }
    }
};
```

### 3.7 leetcode 198 打家劫舍 medium

#### tag dp 模板

#### 题目描述

```
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 

示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
 

提示：

0 <= nums.length <= 100
0 <= nums[i] <= 400
```

#### 思路

一道简单的dp，状态转移方程是dp[i]=max(dp[i-1],dp[i-2]+nums[i])

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()==0)return 0;
        if(nums.size()==1)return nums[0];
        vector<int> dp;
        dp.push_back(nums[0]);
        dp.push_back(max(nums[0],nums[1]));
        for(int i=2;i<nums.size();i++){
            dp.push_back(max(nums[i]+dp[i-2],dp[i-1]));
        }
        return dp[nums.size()-1];
    }
};
```

### 3.7 leetcode 122 买卖股票的最佳时机II easy

#### tag 贪心

#### 题目描述

```
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例 3:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
 

提示：

1 <= prices.length <= 3 * 10 ^ 4
0 <= prices[i] <= 10 ^ 4
```

#### 思路

贪心，涨了就卖

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res=0;
        int min=INT_MAX;
        for(int i=0;i<prices.size();i++){
            if(prices[i]<=min){
                min=prices[i];
            }else{
                res+=(prices[i]-min);
                min=prices[i];
            }
        }
        return res;
    }
};
```

### 3.7 leetcode 518 零钱兑换II medium

#### tag dp 模板

#### 题目描述

```
518. 零钱兑换 II
给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

 

示例 1:

输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
示例 2:

输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。
示例 3:

输入: amount = 10, coins = [10] 
输出: 1
 

注意:

你可以假设：

0 <= amount (总金额) <= 5000
1 <= coin (硬币面额) <= 5000
硬币种类不超过 500 种
结果符合 32 位符号整数
```

#### 思路

开始用了回溯，但是部分用例超时了

本题是经典的dp题

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res=0;
        int min=INT_MAX;
        for(int i=0;i<prices.size();i++){
            if(prices[i]<=min){
                min=prices[i];
            }else{
                res+=(prices[i]-min);
                min=prices[i];
            }
        }
        return res;
    }
};
```

### 3.7 leetcode 53 最大子序和 easy

#### tag dp

#### 题目描述

```
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1
示例 3：

输入：nums = [0]
输出：0
示例 4：

输入：nums = [-1]
输出：-1
示例 5：

输入：nums = [-100000]
输出：-100000
 

提示：

1 <= nums.length <= 3 * 104
-105 <= nums[i] <= 105
 

进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
```

#### 思路

dp数组用于记录以每个位置为终点的子序列和的最大值，显然dp[i]=max(nums[i],nums[i]+dp[i-1])

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int>dp;
        int res=nums[0];
        dp.push_back(nums[0]);
        for(int i=1;i<nums.size();i++){
            dp.push_back(max(nums[i],nums[i]+dp[i-1]));
            if(dp.back()>res)
                res=dp.back();
        }
        return res;
    }
};
```

### 3.7 leetcode 40 组合总和II medium

#### tag 回溯

#### 题目描述

```
给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：

所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
示例 1:

输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
示例 2:

输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
```

#### 思路

这题是组合总和的升级版，出现了重复数字，且数组中的每一项在每个组合只能用一次，最后结果还需要去重

所以这里在回溯时将index的值从i变为i+1（数组中每一项只能用一次）

去重的关键在于这一行**if(i>index && candidates[i]==candidates[i-1])continue;**（前提是已经排序好了）

尤其是这个**i>index**！！！，精髓就是在每次相同递归深度的不会重复，而不同递归深度不受影响。比如[1,1,2,5,6,7,10]中，[1,1,6]能正常产生，但不会有两个[1,7]

```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<int> record;
        sort(candidates.begin(),candidates.end());
        search(candidates,target,record,0);
        return res;
    }
    void search(vector<int>& candidates, int target,vector<int>& record,int index){
        if(target<0)return;
        else if(target==0){
            res.push_back(record);
        }
        else{
            for(int i=index;i<candidates.size();i++){
                if(i>index&&candidates[i]==candidates[i-1])continue;
                record.push_back(candidates[i]);
                search(candidates,target-candidates[i],record,i+1);
                record.pop_back();
            }
        }
    }
};
```

