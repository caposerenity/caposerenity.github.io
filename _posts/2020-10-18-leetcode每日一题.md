---
layout:     post                    # 使用的布局（不需要改）
title:      leetcode每日一题               # 标题 
subtitle:    #副标题
date:       2020-10-18              # 时间
author:     serenity                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - leetcode
    - 算法
---

## 给今年底/明年打工面试做点准备

### 10.18 leetcode19 删除链表的倒数第N个节点 medium

#### tag：双指针

#### 题目

```markdown
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
说明：

给定的 n 保证是有效的。

进阶：

你能尝试使用一趟扫描实现吗？
```

#### 思路

双指针，fast先走n步，这样fast到尾部时slow指向倒数第n个，注意判断下特例

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        int len=1;
        ListNode* fast=head;
        ListNode* slow=head;
        for(int i=0;i<n-1;i++){
            fast=fast->next;
        }
        if(fast->next==nullptr&&fast==head){
            return nullptr;
        }
        else if(fast->next==nullptr){
            fast=head->next;
            head->next=nullptr;
            return fast;
        }
        fast=fast->next;
        while(fast->next!=nullptr){
            slow=slow->next;
            fast=fast->next;
        }
        slow->next=slow->next->next;
        return head;
    }
};
```



### 10.20 leetcode143 重排链表 medium

#### tag：双指针 链表反转

#### 题目

```markdown
给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:

给定链表 1->2->3->4, 重新排列为 1->4->2->3.
示例 2:

给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3
```

#### 思路

先用双指针确定中点（fast速度是slow两倍），再分成两个链表后将后一半反转，两个链表再依次取值

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
 //双指针
class Solution {
public:
    void reorderList(ListNode* head) {
        if(head==nullptr||head->next==nullptr)
            return ;
        ListNode* fast=head;
        ListNode* slow=head;
        //fast速度为slow两倍,slow定位至middle
        while(!(fast->next==nullptr||fast->next->next==nullptr)){
            fast=fast->next->next;
            slow=slow->next;
        }
        fast=head;//存return
        ListNode* middle=slow->next;
        slow->next=nullptr;
        ListNode* temp=nullptr;
        middle=reverse(middle);
        while(head!=nullptr&&middle!=nullptr){
            temp=middle->next;
            middle->next=head->next;
            head->next=middle;
            head=middle->next;
            middle=temp;
        }
        return ;
    }
    ListNode* reverse(ListNode* head){
        ListNode *p1 = NULL;
        ListNode *p2 = head;
        ListNode *p3 = p2;
        
        while(p2){
            p3 = p2->next;
            p2->next = p1;
            p1 = p2;
            p2 = p3;            
        }
        return p1;
    }
};
```

#### 其他思路

不反转后半段，而是使用栈来处理



### 10.21 leetcode925 长按键入 easy

#### tag：双指针 字符串

#### 题目

```markdown
你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。

你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。

 

示例 1：

输入：name = "alex", typed = "aaleex"
输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。
示例 2：

输入：name = "saeed", typed = "ssaaedd"
输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。
示例 3：

输入：name = "leelee", typed = "lleeelee"
输出：true
示例 4：

输入：name = "laiden", typed = "laiden"
输出：true
解释：长按名字中的字符并不是必要的。
 

提示：

name.length <= 1000
typed.length <= 1000
name 和 typed 的字符都是小写字母。
 
```

#### 思路

双指针对应typed和name，typed的每一个char要么匹配name中的一个char，要么和typed前一个相同，否则即为false

```cpp
class Solution {
public:
    bool isLongPressedName(string name, string typed) {
        int i = 0, j = 0;
        while (j < typed.length()) {
            if (i < name.length() && name[i] == typed[j]) {
                i++;
                j++;
            } else if (j > 0 && typed[j] == typed[j - 1]) {
                j++;
            } else {
                return false;
            }
        }
        return i == name.length();
    }
};
```



### 10.22 leetcode763 划分字母区间 medium

#### tag：哈希 贪心

#### 题目

```markdown
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。

 

示例 1：

输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
 

提示：

S的长度在[1, 500]之间。
S只包含小写字母 'a' 到 'z' 。
 
```

#### 思路

先遍历一遍记录所有字母的最后出现的位置（end），使用hash（map）存储。在进行指针遍历时，使用segend记录当前段的终点（每一次前进先更新segend，为max（segend,map[S[I]]）），当i=segend时即即为一个段。

```cpp
class Solution {
public:
    vector<int> partitionLabels(string S) {
        vector<int> res;
        unordered_map<char, int> map;
        for(int i=0;i<S.length();i++){
            map[S[i]]=i;
        }//遍历记录每个字母end
        int segend=map[S[0]];
        int rec=0;
        for(int i=0;i<S.length();i++){
            if(map[S[i]]>segend){
                segend=map[S[i]];
            }
            if(i==segend){
                segend=0;
                res.push_back(i-rec+1);
                rec=i+1;
            }
        }
        if(res.size()==0)
            res.push_back(S.length());
        return res;

    }
};
```



### 10.23 leetcode234 回文链表 easy

#### tag：快慢指针

#### 题目

```markdown
请判断一个链表是否为回文链表。

示例 1:

输入: 1->2
输出: false
示例 2:

输入: 1->2->2->1
输出: true
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
 
```

#### 思路

类似10.20的重排链表那题。先用快慢指针（fast为两倍速）确定中点，后半段反转后再和前半段一一对比。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* fast=head;
        ListNode* slow=head;
        if(fast==nullptr)
            return true;
        while(fast->next!=nullptr&&fast->next->next!=nullptr){
            fast=fast->next->next;
            slow=slow->next;
        }
        ListNode* middle=reverse(slow->next);
        while(head!=nullptr&&middle!=nullptr){
            if(head->val!=middle->val)
                return false;
            head=head->next;
            middle=middle->next;
        }
        return true;
    }
    ListNode* reverse(ListNode* head){
        ListNode *p1 = NULL;
        ListNode *p2 = head;
        ListNode *p3 = p2;
        
        while(p2){
            p3 = p2->next;
            p2->next = p1;
            p1 = p2;
            p2 = p3;            
        }
        return p1;
    }
};
```





### 11.9 leetcode973 最接近原点的K个点 medium

#### tag：堆 队列 hash/快排

#### 题目

```markdown
我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。

（这里，平面上两点之间的距离是欧几里德距离。）

你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。

 

示例 1：

输入：points = [[1,3],[-2,2]], K = 1
输出：[[-2,2]]
解释： 
(1, 3) 和原点之间的距离为 sqrt(10)，
(-2, 2) 和原点之间的距离为 sqrt(8)，
由于 sqrt(8) < sqrt(10)，(-2, 2) 离原点更近。
我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。
示例 2：

输入：points = [[3,3],[5,-1],[-2,4]], K = 2
输出：[[3,3],[-2,4]]
（答案 [[-2,4],[3,3]] 也会被接受。）
```

#### 思路

一开始想通过维护一个大小为k的队列，并用hash减少平方值运算次数，对队列内插入时进行排序，但超时了 【时间复杂度O（nk）】

修改后使用大顶堆维护队列,（cpp的优先队列默认是一个大顶堆）【时间复杂度O（nlogk）】

```cpp
//初始解法
class Solution {
public:
    bool compare(vector<int> a,vector<int> b){
        return (a.at(0)*a.at(0)+a.at(1)*a.at(1))<(b.at(0)*b.at(0)+b.at(1)*b.at(1));
    }
    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {
        vector<pair<int, vector<int>>> res;
        for(int i=0;i<points.size();i++){
            int x=points[i][0],y=points[i][1];
            pair<int,vector<int>> p(x*x+y*y,points[i]);
            if(res.size()>=K){
                if(p.first<res.at(K-1).first){
                    res.pop_back();
                }
                else
                    continue;
            }
                int pos=0;
                if(res.size()==0){
                    res.push_back(p);
                    continue;
                }
                while(pos<res.size()){
                    if(p.first<res.at(pos).first){
                        vector<pair<int, vector<int>>>::iterator iter=res.begin()+pos;
                        res.insert(iter,p);
                        break;
                    }
                    pos++;
                }
                if(pos==res.size())
                    res.push_back(p);
            }
            vector<vector<int>> result(K);
            for (int i = 0; i < K; i++) {
                result[i] = res[i].second;
            }
            return result;
        }

};
//使用大顶堆
class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {
        priority_queue<pair<int, vector<int>>, vector<pair<int, vector<int>>>> res;
        for(int i=0;i<points.size();i++){
            int x=points[i][0],y=points[i][1];
            pair<int,vector<int>> p(x*x+y*y,points[i]);
            res.push(p);
            if(res.size()>K){
                res.pop();
            }
        }
            vector<vector<int>> result(K); // 把队列里元素放入数组
            for (int i = 0; i < K; i++) {
                result[i] = res.top().second;
                res.pop();
            }
            return result;
        }

};
```



### 11.10 leetcode31 下一个排列 medium

#### tag：数组

#### 题目

```markdown
实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

示例 1：

输入：nums = [1,2,3]
输出：[1,3,2]
示例 2：

输入：nums = [3,2,1]
输出：[1,2,3]
示例 3：

输入：nums = [1,1,5]
输出：[1,5,1]
示例 4：

输入：nums = [1]
输出：[1]
 

提示：

1 <= nums.length <= 100
0 <= nums[i] <= 100
```

#### 思路

从后向前遍历，若出现nums[i]>nums[i-1],则说明存在更大的字典排序，取i-1之后的比nums[i-1]大的数字中最小的一个与nums[i-1]交换，再从小到大排序nums[i]及之后的。若始终没有nums[i]>nums[i-1],则已经是字典序最大的情况，则直接整个进行排序

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        bool biggest=true;
        for(int i=nums.size()-1;i>0;i--){
            if(nums.at(i)>nums.at(i-1)){
                int swap=i;
                int temp=0;
                for(int j=i;j<nums.size();j++){
                    if(nums.at(j)<nums.at(swap)&&nums.at(j)>nums.at(i-1))
                        swap=j;    
                }
                temp=nums.at(i-1);
                nums.at(i-1)=nums.at(swap);
                nums.at(swap)=temp;
                sort(nums,i);
                biggest=false;
                break;
            }
        }
        if(biggest)
            sort(nums,0);
    
    }
    void sort(vector<int>& nums,int start){
        for(int i=start;i<nums.size()-1;i++){
            int min=i;
            int temp=0;
            for(int j=i+1;j<nums.size();j++){
                if(nums.at(j)<nums.at(min))
                    min=j;
            }
            temp=nums.at(i);
            nums.at(i)=nums.at(min);
            nums.at(min)=temp;
        }
    }
};
```



### 11.12 leetcode922 按奇偶排序数组II easy

#### tag：数组

#### 题目

```markdown
给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。

对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。

你可以返回任何满足上述条件的数组作为答案。

 

示例：

输入：[4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
 

提示：

2 <= A.length <= 20000
A.length % 2 == 0
0 <= A[i] <= 100
 
```

#### 思路

i：easy，两个向量扫描一遍，当同时出现奇数&偶数不配对的情况时，swap

ii：还可以考虑空间换时间，再开一个res数组，依次往里面填，免去交换过程

```cpp
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& A) {
        int i=0,j=1;
        int temp=0;
        while(i<A.size()&&j<A.size()){
            if(A.at(i)%2!=0&&A.at(j)!=1){
                temp=A.at(i);
                A.at(i)=A.at(j);
                A.at(j)=temp;
            }
            if(A.at(i)%2==0)
                i+=2;
            if(A.at(j)%2==1)
                j+=2; 
        }
        return A;
    }
};
```



### 11.13 leetcode328 奇偶链表 medium

#### tag：双指针+固定指针

#### 题目

```markdown
给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

示例 1:

输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
示例 2:

输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
说明:

应当保持奇数节点和偶数节点的相对顺序。
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。
 
```

#### 思路

感觉挺简单的，一个指针指向奇数，一个指向偶数，交替更换next，最后奇数指针指向固定的偶数开头

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        ListNode* slow=head;
        if(head==nullptr||head->next==nullptr)
            return head;
        ListNode* fast=head->next;
        ListNode* sec=fast;
        while(fast!=nullptr&&fast->next!=nullptr){
            slow->next=fast->next;
            slow=slow->next;
            fast->next=slow->next;
            fast=fast->next;
        }
        slow->next=sec;
        if (fast!=nullptr)
            fast->next=nullptr;
        return head;
    }
};
```



### 1.27 leetcode25 K个一组翻转链表 hard

#### tag 链表 模拟 高频

#### 题目

```
给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

 

示例：

给你这个链表：1->2->3->4->5

当 k = 2 时，应当返回: 2->1->4->3->5

当 k = 3 时，应当返回: 3->2->1->4->5

 

说明：

你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
```

#### 思路

本题思路非常清晰，即通过快慢指针依次确定若干组k个节点进行翻转（*链表翻转见leetcode206*），需要注意的是，本题的困难点在于**一个局部链表翻转前后的连接**。

以1->2->3->4->5，k=2时为例

比如翻转3,4时需要将3，4前后先断开，变为1->2  3->4  5，翻转后再连接上，变为1->2->4->3->5

这就要求我们记录原来链表中**3的前一个结点**（代码中的hair）和**4的后一个节点**（代码中的temp），为了使得第一组k个元素也可以这样操作（同时保证了最终结果的返回值固定为pre->next），我们在链表最前方添加一个节点pre，即变为pre->1->2->3->4->5

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* pre=new ListNode(0,head);
        ListNode* fast=pre;
        ListNode* hair=pre;
        ListNode* temp=nullptr;
        while(1){
            for(int i=0;i<k;i++){
                fast=fast->next;
                if(fast==nullptr)
                    return pre->next;//返回值，最终结果
            }
            temp=fast->next;//temp用来保存断开连接前的后继节点
            fast->next=nullptr;
            hair->next=reverse(head);
            fast=head;//此时head已经从局部链表头部变为尾部
            fast->next=temp;//重新连接链表
            hair=fast;
            head=temp;
        }
        
    }

    ListNode* reverse(ListNode* head){
        ListNode* before=nullptr;
        ListNode* after=nullptr;
        ListNode* tail=head;
        while(head!=nullptr){
            after=head->next;
            head->next=before;
            before=head;
            head=after;
        }
        return before;
    }
};
```

### 1.27 leetcode 3 无重复字符的最长子串 medium

#### tag 滑动窗口

#### 题目

```
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

 

示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
示例 4:

输入: s = ""
```

#### 思路

用滑动窗口解决，使用一个hashmap记录存在的字符，当right的字符已经存在时，更新left位置和hashmap

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.length()==0) return 0;
        int left=0,right=0,len=1,res=1;
        map<char,int> mymap;
        mymap.insert(pair<char,int>(s[0],0));
        while(1){
            if(right<s.length()-1) right++;
            else return res;
            if(mymap.find(s[right])==mymap.end()){
                len++;
                mymap.insert(pair<char,int>(s[right],right))
            }else {
				int temp = mymap[s[right]] + 1;
				for (int i = left; i < mymap[s[right]]; i++) {
					mymap.erase(s[i]);
				}
                //很奇怪，这里循环中如果将原先重复字符的map记录也删掉的话，跳出循环后该记录又会自动加上
				mymap[s[right]] = right;
				left = temp;
				len = right - left + 1;
			}
            if(len>res) res=len;
        }
    }
};
```



### 1.29 leetcode 15 三数之和 medium

#### tag 双指针

#### 题目描述

```
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

 

示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
示例 2：

输入：nums = []
输出：[]
示例 3：

输入：nums = [0]
输出：[]
 

提示：

0 <= nums.length <= 3000
-10^5 <= nums[i] <= 10^5
```

#### 思路

暴力解法的时间复杂度为O（N^3），我们对此进行的优化为先进行排序，再根据确定的第一个指针来判断此情况下p2和p3可能的取值，由于需要a+b+c=0，a确定的情况下，b越大则c越小，所以我们使用双指针方法，b从p1+1位置开始向后遍历，c从尾部向前遍历，相遇则对于这个a的值结束。

另外一个需要注意的点是元组不可相同，因此我们遇到和先前一个值相同的情况直接跳过（这也是为什么我们锚定p1而不是p2，因为对于-4，-1，-1，0，1，2这样的情况而言，锚定p1时p2，p3的取值情况会被后续完整包括，，而如果锚定p2则不能，如上述例子中，锚定p2的话，如果也采用相同就跳过的方式，则会漏掉-1，-1，2的组合）

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
       vector<vector<int>> res;
		if (nums.size() < 3) return res;
		sort(nums.begin(), nums.end());
		int p1 = 0, p3 = nums.size() - 1, p2,sum;
		for (p1 = 0; p1 < nums.size()-2; p1++) {
			p2 = p1+1, p3 = nums.size() - 1;
			if (p1 != 0 && nums[p1] == nums[p1 - 1]) continue;
			while (p2 != p3) {
				sum = nums[p1] + nums[p2] + nums[p3];
				if (sum == 0) {
					vector<int> rec = { nums[p1], nums[p2], nums[p3] };
					res.push_back(rec);
					if (p2 < p3) {
						p2++;
						while (nums[p2] == nums[p2 - 1] && p2 < p3) p2++;
					}
					else { break; }
				}
				else if (sum < 0) {
					p2++;
					while (nums[p2] == nums[p2 - 1]&&p2<p3) p2++;
				}
				else {
					p3--;
					while (nums[p3] == nums[p3 + 1] && p3 > p2) p3--;
				}
			}
		}
		return res;
        
    }
};
```

### 3.1 leetcode 103 二叉树的锯齿形层序遍历 medium

#### tag BFS

#### 题目描述

```
给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层序遍历如下：

[
  [3],
  [20,9],
  [15,7]
]
```

#### 思路

一开始想的是BFS+对每一层交替使用栈和队列，后来发现不用这么麻烦，bfs的时候对于一层的结果暂存时进行一下判断，若是需要逆转就reverse后再加入res中。

这题需要注意的是，bfs过程中如何按层存储（在开始每一层的遍历前先记录下当前队列的大小）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<int>t;
        queue<TreeNode*> store;
        bool rev=false;
        vector<vector<int>> res;
        store.push(root);
        while(store.size()!=0){
            int count=store.size();
            for(int i=0;i<count;i++){
                root=store.front();
                store.pop();
                if(root!=NULL){
                    t.push_back(root->val);
                    store.push(root->left);
                    store.push(root->right);
                }
            }
            if(rev){
                reverse(t.begin(),t.end());
            }
            if(t.size()!=0)
                res.push_back(t);
            t.clear();
            rev=!rev;
        }
        return res;
    }
};
```

### 3.1 leetcode 121 买卖股票的最佳时机 medium

#### tag 动态规划

#### 题目描述

```
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

 

示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 

提示：

1 <= prices.length <= 105
0 <= prices[i] <= 104
```

#### 思路

一次遍历，p为指针，同时用mins记录p之前的最小值

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res=0;
        int p=0,mins=prices[0];
        while(p<prices.size()){
            mins=min(prices[p],mins);
            res=max(res,prices[p]-mins);
            p++;
        }

        return res;
    }
};
```

### 3.4 leetcode 146 LRU缓存机制 medium

#### tag 双向链表 hash

#### 题目描述

```
运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。
实现 LRUCache 类：

LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。
 

进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？

 

示例：

输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

#### 思路

由于要求在O(1)内完成，很显然要用hash的来存取。但是hash无法实现有序存储（即根据访问时间进行lru），这里又需要我们用一个list或者vector来存储，但vector这里数组的删除复杂度为O(N)，因此我们选用双向链表（双向是为了便于添加删除），链表的节点存储key和val（链表也存储key是为了便于在map中删除时根据head节点获取要删除的key）。

另一个trick是使用链表时，为了减少边界情况的if判断，可以使用一个head和tail节点

```cpp
struct Node {
	int key, val;
	Node *prev;
	Node *next;
	Node(int key, int x) :key(key), val(x), prev(NULL), next(NULL) {}
};

class LRUCache {
public:
	LRUCache(int capacity) {
		cap = capacity;
	}

	int get(int key) {
		if (m.find(key) != m.end()) {
			p = m.at(key);
			p->prev->next = p->next;
			p->next->prev = p->prev;

			p->next = tail;
			p->prev = tail->prev;
			tail->prev->next = p;
			tail->prev = p;

			return m.at(key)->val;
		}
		else {
			return -1;
		}
	}

	void put(int key, int value) {
		if (m.size() == 0) {
			p = new Node(key, value);
			m.insert(pair<int, Node*>(key, p));
			head = new Node(-1, -1);;
			tail = new Node(-1, -1);;
			head->next =p; 
			tail->prev = p;
            p->next=tail;
            p->prev=head;
		}
		else if( m.find(key) != m.end()) {
            //将其移动至链表尾部并修改value
				p = m.at(key);
				p->val = value;
				p->prev->next = p->next;
				p->next->prev = p->prev;

				p->next = tail;
				p->prev = tail->prev;
				tail->prev->next = p;
				tail->prev = p;
			}
            else{
                if (m.size() < cap) {
                    p = new Node(key, value);
                    p->next = tail;
                    p->prev = tail->prev;
                    tail->prev->next = p;
                    tail->prev = p;
                    m.insert(pair<int, Node*>(key, p));
                }
		else {
			//删除头部节点,插入新node至尾部
			p = new Node(key, value);
			m.erase(head->next->key);
			head->next->next->prev = head;
			head->next = head->next->next;
			p->next = tail;
			p->prev = tail->prev;
			tail->prev->next = p;
			tail->prev = p;
			m.insert(pair<int, Node*>(key, p));
		}
        }
	}
private:
	int cap;
	Node* head = nullptr;
	Node* tail = nullptr;
	Node* p = nullptr;
	vector<int> cache;
	unordered_map<int, Node*> m;

};
/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

### 3.4 leetcode 105 从前序和中序构建二叉树 medium

#### tag 树 递归

#### 题目描述

```
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7

```

#### 思路

递归题，模拟大脑内构建这棵二叉树的过程

先获取前序中的[0]作为root，在中序中定位后，中序[index]左侧为左子树，右侧为右子树，递归。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size()==0){
            return NULL;
        }else{
            TreeNode* root=new TreeNode(preorder[0]);
            vector<int>::iterator result=find(inorder.begin(),inorder.end(),preorder[0]             );
            int index=distance(inorder.begin(), result);
            vector<int>a(preorder.begin()+1,preorder.begin()+1+index);
            vector<int>b(inorder.begin(),inorder.begin()+index);
            root->left=buildTree(a,b);
            vector<int>c(preorder.begin()+1+index,preorder.end());
            vector<int>d(inorder.begin()+index+1,inorder.end());
            root->right=buildTree(c,d);
            return root;
        }   
    }
};
```

### 3.4 leetcode 199 二叉树的右视图 medium

#### tag BFS

#### 题目描述

```
给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---

```

#### 思路

和lc103 二叉树锯齿状遍历很像

这题需要注意的是，bfs过程中如何按层存储（在开始每一层的遍历前先记录下当前队列的大小）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int>res;
        queue<TreeNode*> q;
        q.push(root);
        if(root==NULL||q.size()==0)
            return res;
        while(q.size()>0){
            int size=q.size();
            for(int i=0;i<size;i++){
                TreeNode* temp=q.front();
                q.pop();
                if(i==size-1){
                    res.push_back(temp->val);
                }
                if(temp->left!=NULL)
                    q.push(temp->left);
                if(temp->right!=NULL)
                    q.push(temp->right);
            }
        }
        return res;
    }
};
```

### 3.4 leetcode 160 相交链表 easy

#### tag 脑筋急转弯

#### 题目描述

```
编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表：



在节点 c1 开始相交。

 

示例 1：



输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
 

示例 2：



输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
 

示例 3：



输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
 

注意：

如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

```

#### 思路

脑筋急转弯题目。。。不知道为啥喜欢考这种

思路是两个链表相加的总长度是一定的，因此两个指针分别从A、B出发，以A->B和B->A两条路径，如果是有交点的，则必然在路径上某点相遇（交点），否则不会相遇。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *p1=headA;
        ListNode *p2=headB;
        int a=0,b=0;
        if(p1!=NULL&&p2!=NULL){
        while(a<2&&b<2){
            if(p1==NULL){
                p1=headB;
                a++;
            }
            if(p2==NULL){
                p2=headA;
                b++;
            }
            if(p1==p2)
                return p1;
            p1=p1->next;
            p2=p2->next;
        }
        }
        return NULL;
    }
};
```

### 3.4 leetcode 54 螺旋矩阵 medium

#### tag 模拟

#### 题目描述

```
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

示例:

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]

```

#### 思路

直接暴力模拟，很像大一的那种题目

标记一下矩阵内已经访问过的地方，根据direction变量来判断移动方位。边界情况下改变移动方向。

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        const int no=-999;
        int m=matrix.size();
        int n=matrix[0].size();
        int direction=0;//0右 1下 2左 3上
        for(int i=0,j=0,count=0;count<m*n;count++){
            res.push_back(matrix[i][j]);
            matrix[i][j]=no;
            switch(direction){
                case 0:
                    if(j==n-1||matrix[i][j+1]==no){
                        direction=1;
                        i++;
                    }
                    else
                        j++;
                    break;
                case 1:
                    if(i==m-1||matrix[i+1][j]==no){
                        direction=2;
                        j--;
                    }
                    else
                        i++;
                    break;
                case 2:
                    if(j==0||matrix[i][j-1]==no){
                        direction=3;
                        i--;
                    }
                    else
                        j--;
                    break;
                case 3:
                    if(i==0||matrix[i-1][j]==no){
                        direction=0;
                        j++;
                    }
                    else
                        i--;
                    break;  
            }
            
        }

        return res;
    }

};
```

### 3.4 leetcode 21 合并两个有序链表 easy

#### tag 链表

#### 题目描述

```
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

示例 1：


输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
示例 2：

输入：l1 = [], l2 = []
输出：[]
示例 3：

输入：l1 = [], l2 = [0]
输出：[0]

提示：
两个链表的节点数目范围是 [0, 50]
-100 <= Node.val <= 100
l1 和 l2 均按 非递减顺序排列
```

#### 思路

简单题……直接加

注意用一下伪头部，减少if判断

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* l=new ListNode(0);
        ListNode* backup=l;
        while(l1!=nullptr&&l2!=nullptr){
            if(l1->val<=l2->val){
                l->next=l1;
                l1=l1->next;
                l=l->next;
            }else{
                l->next=l2;
                l2=l2->next;
                l=l->next;
            }
        }
        if(l1==nullptr){
            l->next=l2;
        }else{
            l->next=l1;
        }

        return backup->next;
    }
};
```

### 3.5 leetcode 42 接雨水 hard

#### tag 双指针

#### 题目描述

```
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

 

示例 1：

输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
示例 2：

输入：height = [4,2,0,3,2,5]
输出：9

```

#### 思路

思路的重点在于想到对于每一列i，它能接的雨水量是由它左侧最高的一列和右侧最高的一列所决定的。

因此，我们先用从左向右和从右向左的两次遍历求出对于每一列i，它的左侧最高一列leftMax和右侧最高一列rightMax。再计算二者中较小值和自身的差值。

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int res=0;
        vector<int> left;
        vector<int> right;
        int n=height.size();
        for(int i=0,leftMax=0;i<n;i++){
            if(leftMax<height[i]){
                leftMax=height[i];
            }
            left.push_back(leftMax);
        }
        for(int i=n-1,rightMax=0;i>=0;i--){
            if(rightMax<height[i]){
                rightMax=height[i];
            }
            right.insert(right.begin(), rightMax);
        }
        for(int i=0;i<n;i++){
            res+=(min(left[i],right[i])-height[i]);
        }
        return res;
    }
};
```

### 3.5 leetcode 69 x的平方根 easy

#### tag 二分查找

#### 题目描述

```
实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:

输入: 4
输出: 2
示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
```

#### 思路

显然暴力解法是从0开始依次尝试满足i\^2<=x且(i+1)\^2>x的解

对于这类查找题显然可以用二分法化简，本题也可以作为二分查找的模板题

```cpp
class Solution {
public:
    int mySqrt(int x) {
        //二分查找
        if(x==0)return 0;
        if(x==1)return 1;
        int max=x,min=0,res=1;
        while(max-min>1){
            res=(min+max)/2;
            if(res*res<=x)
                min=res;            
            else
                max=res;
        }

        return min;
    }
};
```

### 3.5 leetcode 33 搜索旋转排序数组 medium

#### tag 二分查找

#### 题目描述

```
整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。

 

示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
示例 3：

输入：nums = [1], target = 0
输出：-1
 

提示：

1 <= nums.length <= 5000
-10^4 <= nums[i] <= 10^4
nums 中的每个值都 独一无二
nums 肯定会在某个点上旋转
-10^4 <= target <= 10^4

进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？
```

#### 思路

排序+二分的方法无法满足O(log n)的复杂度要求，本题是二分查找的一个变种问题

可以看到，由于只有一个“断层点”。对于原数组，我们将其二分后，必然有一半是排好序的，另一半则可能是乱序的。而对于这个乱序的一半，再次二分后，又得出一半排好序的和另一半可能乱序…

因此，我们可以根据target值是否在排好序的一侧来判断，若在，则对排好序的一侧进行二分查找。若不在，对可能乱序的一侧我们继续进行二分迭代。

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left=0,right=nums.size()-1,m=-1;
        if(right==-1)return -1;
        if(right==0)return nums[0]==target?0:-1;
        while(right>=left){
            m=left+(right-left)/2;
            if(nums[m]==target)return m;
            if(nums[m]<nums[right]){
                //右侧有序
                if(nums[m]<=target&&nums[right]>=target){
                    left=m+1;
                }else{
                    right=m-1;
                }
            }else{
                //左侧有序
                if(nums[m]>=target&&nums[left]<=target){
                    right=m-1;
                }else{
                    left=m+1;
                }
            }
        }
        return -1;
    }
};
```

### 3.5 leetcode 124 二叉树中的最大路径和 hard

#### tag DFS

#### 题目描述

```
径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。

示例 1：
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
示例 2：

输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

#### 思路

对于经过一个节点，我们将其自身的值、左子树的值、右子树的值看成三个部分。

而一个节点在路径中有三种情况：

一种是仅仅使用了它自身的值（如左右子树均为负值）（其实可以看成是第三种的一个特殊情况）

一种是它作为“路径根节点”（如左右子树均为正，形成一条路径来和当前路径和的最大值比较）

一种是它作为更高层次根节点的路径的一部分，最多只能使用它的一条子树。

因此，我们可以从根节点向下递归求每个节点作为“路径根节点”的最大路径，并依次和当前路径和的最大值比较

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int m=-9999;
    int cal(TreeNode* node){
        if(node==NULL) return 0;
        int l=cal(node->left);
        int r=cal(node->right);
        int res=node->val;
        if(l>0)res+=l;
        if(r>0)res+=r;
        if(res>m)m=res;
        if(l>0&&r>0)res-=min(l,r);
        return res;
    }

    int maxPathSum(TreeNode* root) {
        cal(root);
        return m;
    }
};
```

### 3.5 leetcode 155 最小栈 easy

#### tag 数据结构

#### 题目描述

```
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。
 

示例:

输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
 

提示：

pop、top 和 getMin 操作总是在 非空栈 上调用。
```

#### 思路

直接模拟栈就完事了

这题需要注意的是，pop时需要更新栈内的最小值，且这个操作需要在常数时间内完成。因此我们需要存储每次push之后栈内的最小值。我这里采用的方式是每次往栈内push两个数：x和本次操作后栈内最小值。

```cpp
class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {
        //minNum=INT_MAX;
    }
    
    void push(int x) {
        if(stack.size()==0)
            minNum=x;
        if(x<minNum){
            minNum=x;
        }
        stack.push_back(minNum);
        stack.push_back(x);
    }
    
    void pop() {
        stack.pop_back();
        stack.pop_back();
        if(stack.size()>0)
            minNum=stack.at(stack.size()-2);
    }
    
    int top() {
        return stack.back();
    }
    
    int getMin() {
        return minNum;
    }
private:
    int minNum;
    deque<int> stack;
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```

### 3.5 leetcode 236 二叉树的最近公共祖先 medium

#### tag dfs

#### 题目描述

```
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

示例 1：


输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
示例 2：


输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
示例 3：

输入：root = [1,2], p = 1, q = 2
输出：1
 
提示：
树中节点数目在范围 [2, 105] 内。
-109 <= Node.val <= 109
所有 Node.val 互不相同 。
p != q
p 和 q 均存在于给定的二叉树中。
```

#### 思路

一上来就想到了要用递归DFS做，对于每个节点我们判断它是否是p、q的公共祖先时，这取决于它的两个子节点（及其自身）是否p、q的公共祖先。这里为了便于判断，我用计数方式来表示是否为p/q的祖先，即若是p的祖先则+1，若是q的则+2。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> v;
    int dfs(TreeNode* node,TreeNode* p,TreeNode* q){
        if(node==NULL)return 0;
        int res=0;
        if(node==p)res+=1;
        if(node==q)res+=2;
        int l=dfs(node->left,p,q);
        int r=dfs(node->right,p,q);
        res=res+l+r;
        if(res==3)
            v.push_back(node);
        return res;
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        dfs(root,p,q);
        return v.front();
    }
};
```

### 3.5 leetcode 415 字符串相加 easy

#### tag 字符串

#### 题目描述

```
给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

 

提示：

num1 和num2 的长度都小于 5100
num1 和num2 都只包含数字 0-9
num1 和num2 都不包含任何前导零
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式
```

#### 思路

简单题……

```cpp
class Solution {
public:
    string addStrings(string num1, string num2) {
        string res="";
        int len1=num1.length(),len2=num2.length();
        int plus=0;
        reverse(num1.begin(), num1.end());
        reverse(num2.begin(), num2.end());
        if(len1<len2){
            for(int i=0;i<len2-len1;i++){
                num1+="0";
            }
        }else{
            for(int i=0;i<len1-len2;i++){
                num2+="0";
            }
        }
        int l=max(len1,len2);
        for(int i=0;i<l;i++){
            res+=('0'+(num1.at(i)-'0'+num2.at(i)-'0'+plus)%10);
            plus=((num1.at(i)-'0'+num2.at(i)-'0'+plus)/10);
        }
        if(plus!=0)
            res+=('0'+plus);
        reverse(res.begin(), res.end());
        return res;
    }
};
```

### 3.5 leetcode 1 两数之和 easy

#### tag hash

#### 题目描述

```
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。

 

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]
 

提示：

2 <= nums.length <= 103
-109 <= nums[i] <= 109
-109 <= target <= 109
只会存在一个有效答案
```

#### 思路

由于只存在一个答案，所以免去了三数之和中的排序过程。

我们可以直接使用一个hash来存储遍历过程中的<num,index>对，对于遍历到的某个点i，我们检查map中是否有对应的target-nums[i]，若没有则将i也加入map

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        map<int,int>m;
        vector<int>res;
        for(int i=0;i<nums.size();i++){
            if(m.find(target-nums[i])!=m.end()){
                res.push_back(m.at(target-nums[i]));
                res.push_back(i);
                return res;
            }else{
                m.insert(pair<int,int>(nums[i],i));
            }
        }
        return res;
    }
};
```

### 3.5 leetcode 23 合并K个升序链表 hard

#### tag hash

#### 题目描述

```
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

 

示例 1：

输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
示例 2：

输入：lists = []
输出：[]
示例 3：

输入：lists = [[]]
输出：[]
 

提示：

k == lists.length
0 <= k <= 10^4
0 <= lists[i].length <= 500
-10^4 <= lists[i][j] <= 10^4
lists[i] 按 升序 排列
lists[i].length 的总和不超过 10^4
```

#### 思路

看到题目的第一思路就是用k个指针分别指向这k个链表，每次选择val最小的加入到res中，最终这个写法是可行的，就是时间上有点……但好歹过了

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool check(int k,vector<ListNode*>& lists){
        for(int i=0;i<k;i++){
            if(lists[i]!=NULL)
                return true;
        }
        return false;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        int k=lists.size();
        ListNode* res=new ListNode(0);
        ListNode* root=res;
        while(check(k,lists)){
            int value=INT_MAX;
            int index=-1;
            for(int i=0;i<k;i++){
                if(lists[i]!=NULL&&lists[i]->val<value){
                    value=lists[i]->val;
                    root->next=lists[i];
                    index=i;
                }
            }
            lists[index]=lists[index]->next;
            root=root->next;
        }
        return res->next;
    }
};
```

### 3.5 leetcode 41 缺失的第一个整数 hard

#### tag hash 妙

#### 题目描述

```
给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

 

进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？

 

示例 1：

输入：nums = [1,2,0]
输出：3
示例 2：

输入：nums = [3,4,-1,1]
输出：2
示例 3：

输入：nums = [7,8,9,11,12]
输出：1
 

提示：

0 <= nums.length <= 300
-231 <= nums[i] <= 231 - 1
```

#### 思路

如果这题没有空间复杂度O(1)的要求的话，可以直接遍历数组用hash存储数组出现的正整数。之后再从1开始找不在hash中的。

但由于O(1)的复杂度要求，我们只能在原数组上模拟hash的操作。

这里使用了下标提供的信息，即：考虑到没出现的最小正整数只能在1-n+1中取（最多有n个正整数），我们在第一次遍历时发现某个值i在1-n+1范围内时，就将它交换移动到对应的下标i-1处。这样，在第二次遍历的时候，我们就可以直接返回第一个不对应的数，若都对应，则返回n+1。

需要注意的是，交换这种方法可能会对[1,1]这种测试数据产生死循环，因此条件里额外加了一个nums[nums[i]-1]!=nums[i]。

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n=nums.size();
        int i=0;
        while(i<n){
            if(nums[i]>0&&nums[i]<=n&&nums[i]-1!=i&&nums[nums[i]-1]!=nums[i]){
                int t=nums[nums[i]-1];
                nums[nums[i]-1]=nums[i];
                nums[i]=t;
                i--;
            }
            i++;
        }
        for(int i=0;i<n;i++){
            if(nums[i]!=i+1)
                return i+1;
        }
        return n+1;
    }
};
```

### 3.5 leetcode 141 环形链表 easy

#### tag 快慢指针

#### 题目描述

```
给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。

 

进阶：

你能用 O(1)（即，常量）内存解决此问题吗？
```

#### 思路

快慢指针，如果快指针是慢指针速度的两倍，若有环，则最终能相遇，否则两个指针会有至少一个在中途变为NULL

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *fast=head;
        ListNode *slow=head;
        if(head==NULL||head->next==NULL)
            return false;
        while(fast!=NULL&&slow!=NULL){
            slow=slow->next;
            if(fast->next!=NULL)
                fast=fast->next->next;
            else
                return false;
            if(slow==fast)
                return true;
        }
        return false;
    }
};
```

### 3.5 leetcode 20 有效的括号 easy

#### tag 栈

#### 题目描述

```
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
 

示例 1：

输入：s = "()"
输出：true
示例 2：

输入：s = "()[]{}"
输出：true
示例 3：

输入：s = "(]"
输出：false
示例 4：

输入：s = "([)]"
输出：false
示例 5：

输入：s = "{[]}"
输出：true
 

提示：

1 <= s.length <= 104
s 仅由括号 '()[]{}' 组成
```

#### 思路

非常经典的栈的例题，挺简单的

```cpp
class Solution {
public:
    bool isValid(string s) {
        int n=s.length();
        vector<char> q;
        for(int i=0;i<n;i++){
            switch(s[i]){
                case ')':
                    if(q.size()>0&&q.back()=='(')
                        q.pop_back();
                    else
                        return false;
                    break;
                case '}':
                    if(q.size()>0&&q.back()=='{')
                        q.pop_back();
                    else
                        return false;
                    break;
                case ']':
                    if(q.size()>0&&q.back()=='[')
                        q.pop_back();
                    else
                        return false;
                    break;
                default:
                    q.push_back(s[i]);
                    break;
            }
        }
        if(q.size()==0)
            return true;
        else
            return false;
    }
};
```

### 3.5 leetcode 24 两两交换链表中的节点 medium

#### tag 翻转链表

#### 题目描述

```
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 

示例 1：


输入：head = [1,2,3,4]
输出：[2,1,4,3]
示例 2：

输入：head = []
输出：[]
```

#### 思路

本题是k个一组翻转链表的k取2时的特殊情况，注意使用伪头部化简

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head==NULL||head->next==NULL)
            return head;
        ListNode* hair=new ListNode(0);
        hair->next=head;
        ListNode* before=hair;
        ListNode* after=hair;
        while(head!=NULL&&head->next!=NULL){
            after=head->next->next;
            head->next->next=NULL;
            before->next=NULL;
            head=reverse(head);
            before->next=head;
            head->next->next=after;
            before=head->next;
            head=after;
        }
        return hair->next;
    }
    ListNode* reverse(ListNode* head){
        ListNode* temp=head->next;
        head->next=NULL;
        temp->next=head;
        return temp;
    }
};
```

### 3.6 leetcode 98 验证二叉搜索树 medium

#### tag dfs 中序

#### 题目描述

```
给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
示例 1:

输入:
    2
   / \
  1   3
输出: true
示例 2:

输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

#### 思路

思路一：二叉搜索树的中序排列是有序的（递增），所以只需要走一遍中序排列即可

思路二：DFS递归的时候，带上两个参数max和min，分别标识本次递归允许的上限和下限（如递归root的左子树时，设置上限为root->val，下线为INT_MIN）

```cpp
class Solution {
public:
    long lastVal=LONG_MIN;

    bool isValidBST(TreeNode* root) {
        bool l=true;
        if(root->left!=NULL)
            l=isValidBST(root->left);
        bool m=false;
        if(root->val>lastVal){
            lastVal=root->val;
            m=true;
        }
        bool r=true;
        if(root->right!=NULL)
            r=isValidBST(root->right);
        return l&&r&&m;
    }
};
```

### 3.6 leetcode 79 单词搜索 medium

#### tag dfs 回溯算法

#### 题目描述

```
给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

示例:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false
 

提示：

board 和 word 中只包含大写和小写英文字母。
1 <= board.length <= 200
1 <= board[i].length <= 200
1 <= word.length <= 10^3
```

#### 思路

经典的回溯题，用深搜的写法，逻辑上不难理解，即不停的向四个方向找是否满足下一个char，且维护一个访问过的数组visited（可以在原数组上实现）。主要问题还是在于代码实现上。

```cpp
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        int m=board.size(),n=board[0].size();
        int k=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(dfs(board,word,i,j,k)){
                    return true;
                }
            }
        }
        return false;
    }

    bool dfs(vector<vector<char>>& board, string word,int i,int j,int k){
        if(k==0){
            if(board[i][j]!=word[k])return false;
            else{
                board[i][j]='0';
                if(dfs(board,word,i,j,k+1)){
                    return true;
                }else{
                    board[i][j]=word[k];
                    return false;
                }
            }
        }
        else if(k>=word.length()) return true;
        else{
            if(i-1>=0&&board[i-1][j]==word[k]){
                board[i-1][j]='0';
                if(dfs(board,word,i-1,j,k+1)){
                    return true;
                }else{
                    board[i-1][j]=word[k];
                    //return false;
                }
            }
            if(i+1<board.size()&&board[i+1][j]==word[k]){
                board[i+1][j]='0';
                if(dfs(board,word,i+1,j,k+1)){
                    return true;
                }else{
                    board[i+1][j]=word[k];
                    //return false;
                }
            }
            if(j-1>=0&&board[i][j-1]==word[k]){
                board[i][j-1]='0';
                if(dfs(board,word,i,j-1,k+1)){
                    return true;
                }else{
                    board[i][j-1]=word[k];
                    //return false;
                }
            }
            if(j+1<board[0].size()&&board[i][j+1]==word[k]){
                board[i][j+1]='0';
                if(dfs(board,word,i,j+1,k+1)){
                    return true;
                }else{
                    board[i][j+1]=word[k];
                    //return false;
                }
            }
            return false;
        }

    }
};
```

### 3.6 leetcode 46 全排列 medium

#### tag 回溯算法

#### 题目描述

```
给定一个 没有重复 数字的序列，返回其所有可能的全排列。

示例:

输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

#### 思路

这题也是回溯写法，主层循环里依次选取起始的第一个数字，然后在回溯的过程中将已经走过的地方置为INT_MIN

```cpp
class Solution {
public:
    vector<vector<int>>res;
    
    void dfs(vector<int>& nums,vector<int>&temp){
        if(temp.size()==nums.size()) {
            res.push_back(temp);
            return;
        }else{
            for(int i=0;i<nums.size();i++){
                if(nums[i]!=INT_MIN){
                temp.push_back(nums[i]);
                int t=nums[i];
                nums[i]=INT_MIN;
                dfs(nums,temp);
                temp.pop_back();
                nums[i]=t;
                }
            }
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {    
        vector<int> temp;
        for(int i=0;i<nums.size();i++){
            temp.push_back(nums[i]);
            int t=nums[i];
            nums[i]=INT_MIN;
            dfs(nums,temp);
            nums[i]=t;
            temp.pop_back();
        }
        return res;
    }
};
```

### 3.6 leetcode 2 两数相加 medium

#### tag 链表

#### 题目描述

```
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

示例 1：


输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
示例 2：

输入：l1 = [0], l2 = [0]
输出：[0]
示例 3：

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

#### 思路

挺简单的。。注意一下边界情况

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int plus=0;
        ListNode *hair=new ListNode(0);
        hair->next=l1;
        ListNode* t;
        while(l1!=NULL&&l2!=NULL){
            l1->val=l1->val+l2->val+plus;
            plus=l1->val/10;
            l1->val%=10;
            t=l1;
            l1=l1->next;
            l2=l2->next;
        }
        if(l1==NULL){
            l1=l2;
        }
        t->next=l1;
        while(l1!=NULL){
            l1->val+=plus;
            plus=l1->val/10;
            l1->val%=10;
            t=l1;
            l1=l1->next;
        }
        if(plus!=0){
            l1= new ListNode(plus);
            t->next=l1;
        }
        

        return hair->next;
    }
};
```

### 3.6 leetcode 101 对称二叉树 easy

#### tag BFS/DFS

#### 题目描述

```
给定一个二叉树，检查它是否是镜像对称的。

 

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3
 

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3
 

进阶：

你可以运用递归和迭代两种方法解决这个问题吗？
```

#### 思路

两种方法，dfs先左后右和先右后左如果结果一样，则true，否则不对称

bfs则是对每层判断是否对称，注意null

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        deque<TreeNode*>q;
        q.push_back(root);
        while(!q.empty()){
            int size=q.size();
            vector<int>v;
            for(int i=0;i<size;i++){
                if(q.front()!=NULL){
                    q.push_back(q.front()->left);
                    q.push_back(q.front()->right);
                    v.push_back(q.front()->val);
                }else{
                    v.push_back(INT_MIN);
                }
                q.pop_front();
            }
            if(!check(v))return false;
            v.clear();
        }
        return true;
    }
    bool check(vector<int>& v){
        for(int i=0;i<v.size();i++){
            if(v[i]!=v[v.size()-1-i])
                return false;
        }
        return true;
    }
};
```

### 3.6 leetcode 470 用rand7()实现rand10() medium

#### tag 数学

#### 题目描述

```
已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。

不要使用系统的 Math.random() 方法。

 

示例 1:

输入: 1
输出: [7]
示例 2:

输入: 2
输出: [8,4]
示例 3:

输入: 3
输出: [8,1,10]
 

提示:

rand7 已定义。
传入参数: n 表示 rand10 的调用次数。
 

进阶:

rand7()调用次数的 期望值 是多少 ?
你能否尽量少调用 rand7() ?
```

#### 思路

神奇的数学题

本题的核心在于int a=rand7();

​    int b=rand7();

​    res=(a-1)*7+b;

res的这个表达式生成了一个在1-49之间均匀分布的随机数，这样我们只需要在<=40的时候取模即可，若大于40则再生成一次

```cpp
// The rand7() API is already defined for you.
// int rand7();
// @return a random integer in the range 1 to 7

class Solution {
public:
    int rand10() {
    int res;
    while(1){
        int a=rand7();
        int b=rand7();
        res=(a-1)*7+b;
        if(res<=40)
            break;
    }
    return res%10+1;
    }
};
```

### 3.6 leetcode 958 二叉树的完全性检验 medium

#### tag BFS

#### 题目描述

```
给定一个二叉树，确定它是否是一个完全二叉树。

百度百科中对完全二叉树的定义如下：

若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）

 

示例 1：



输入：[1,2,3,4,5,6]
输出：true
解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。
示例 2：



输入：[1,2,3,4,5,null,7]
输出：false
解释：值为 7 的结点没有尽可能靠向左侧。
 

提示：

树中将会有 1 到 100 个结点。
```

#### 思路

很显然是一道bfs，在null节点之后不能再出现非null节点

```cpp
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
    deque<TreeNode*>q;
    q.push_back(root);
    while(!q.empty()){
        int size=q.size();
        vector<TreeNode*>v;
        for(int i=0;i<size;i++){
            if(q.front()!=NULL){
                q.push_back(q.front()->left);
                q.push_back(q.front()->right);
                v.push_back(q.front());
            }else{
                v.push_back(NULL);
            }
            q.pop_front();
        }
        if(q.size()!=2*size&&q.size()!=0){
            if(!check(v))return false;
        }
        v.clear();
    }
    return true;
    }
    bool check(vector<TreeNode*>& v){
        int last=0,first=-1;
        for(int i=0;i<v.size();i++){
            if(v[i]==NULL){
                if(first==-1)
                 first=i;} 
            else{ if(v[i]->left!=NULL||v[i]->right!=NULL)
                return false;
                last=i;
            }
        }
        if(last<first)
        return true;
        else
        return false;
    }
};
```

### 3.7 leetcode 92 反转链表 II medium

#### tag 链表

#### 题目描述

```
反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

示例:

输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```

#### 思路

简化版的k个一组翻转链表，需要注意的是链表断开后重新连接

```cpp
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode* hair=new ListNode(0);
        hair->next=head;
        ListNode* start=hair;
        ListNode* end=hair;
        for(int i=0;i<left-1;i++){
            start=start->next;
        }
        ListNode* before=start;
        start=start->next;
        for(int i=0;i<right;i++){
            end=end->next;
        }
        before->next=NULL;
        ListNode* after=end->next;
        end->next=NULL;
        vector<ListNode*> v=reverse(start);
        before->next=v[0];
        v[1]->next=after;
        return hair->next;
    }
    vector<ListNode*> reverse(ListNode* head){
        ListNode *t,*before,*after;
        before=NULL;
        t=head;
        after=head;
        while(head!=NULL){
            after=after->next;
            head->next=before;
            before=head;
            head=after;
        }
        vector<ListNode*>v;
        v.push_back(before);
        v.push_back(t);
        return v;
    }
};
```

### 3.7 leetcode 102 二叉树的层序遍历 medium

#### tag BFS

#### 题目描述

```
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

 

示例：
二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层序遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
```

#### 思路

简单的BFS

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        deque<TreeNode*>q;
        q.push_back(root);
        vector<vector<int>>res;
        while(!q.empty()){
            int size=q.size();
            vector<int>v;
            for(int i=0;i<size;i++){
                if(q.front()!=NULL){
                    q.push_back(q.front()->left);
                    q.push_back(q.front()->right);
                    v.push_back(q.front()->val);
                }
                q.pop_front();
            }
            if(v.size()!=0)
            res.push_back(v);
        }
        return res;
        }
};
```

### 3.7 leetcode 162 寻找峰值 medium

#### tag 二分查找

#### 题目描述

```
峰值元素是指其值大于左右相邻值的元素。

给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

 

示例 1：

输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
示例 2：

输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
 

提示：

1 <= nums.length <= 1000
-231 <= nums[i] <= 231 - 1
对于所有有效的 i 都有 nums[i] != nums[i + 1]
 

进阶：你可以实现时间复杂度为 O(logN) 的解决方案吗？
```

#### 思路

想不到吧，这题都能二分……

虽然是乱序的，但是，（即nums[mid]<nums[mid+1]时，mid+1~N一定存在峰值） 我的理解是，首先已知 nums[mid+1]>nums[mid]，那么mid+2只有两种可能，一个是大于mid+1，一个是小于mid+1，小于mid+1的情况，那么mid+1就是峰值，大于mid+1的情况，继续向右推，如果一直到数组的末尾都是大于的，那么可以肯定最后一个元素是峰值，因为nums[nums.length]=负无穷

```cpp
class Solution {
public:
int findPeakElement(vector<int>& nums) {
    int left = 0, right = nums.size() - 1;
    for (; left < right; ) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > nums[mid + 1]) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
};
```

### 3.7 leetcode 114 二叉树展开为链表 medium

#### tag dfs，前序

#### 题目描述

```
给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。
 

示例 1：


输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
示例 2：

输入：root = []
输出：[]
示例 3：

输入：root = [0]
输出：[0]
 

提示：

树中结点数在范围 [0, 2000] 内
-100 <= Node.val <= 100
 

进阶：你可以使用原地算法（O(1) 额外空间）展开这棵树吗？
```

#### 思路

前序遍历

```cpp
class Solution {
public:
    TreeNode* t1;
    void flatten(TreeNode* root) {
        if(root==nullptr||(root->left==nullptr&&root->right==nullptr))
            return;
        if(root->left!=nullptr)
            flatten(root->left);
        if(root->right!=nullptr)
            flatten(root->right);
        t1=root->right;
        if(root->left!=nullptr){
            root->right=root->left;
            root->left=nullptr;
            while(root->right->right!=nullptr){
                root=root->right;
            }
            root->right->right=t1;
        }
        
        return;
    }
};
```

### 3.7 leetcode 56 合并区间 medium

#### tag 排序

#### 题目描述

```
以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

 

示例 1：

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2：

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
 

提示：

1 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti <= endi <= 104
```

#### 思路

根据left排序，显然只能相邻的才有可能合并

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if(intervals.size()==0)return intervals;
        sort(intervals.begin(),intervals.end());
        vector<vector<int>> res;
        res.push_back(intervals[0]);
        int n=0;
        for(int i=1;i<intervals.size();i++){
            if(intervals[i][0]<=res[n][1]){
                res[n][1]=max(res[n][1],intervals[i][1]);
            }else{
                res.push_back(intervals[i]);
                n++;
            }
        }
        return res;
    }
};
```

### 3.7 leetcode 39 组合综合 medium

#### tag 回溯 模板

#### 题目描述

```
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
示例 1：

输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
示例 2：

输入：candidates = [2,3,5], target = 8,
所求解集为：
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
 

提示：

1 <= candidates.length <= 30
1 <= candidates[i] <= 200
candidate 中的每个元素都是独一无二的。
1 <= target <= 500
```

#### 思路

非常标准的回溯模板题

需要注意的是，为了防止重复（如[2，2，3]和[2，3，2]）这种，需要一个index来指定从哪里开始遍历

```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<int> record;
        search(candidates,target,record,0);
        return res;
    }
    void search(vector<int>& candidates, int target,vector<int>& record,int index){
        if(target<0)return;
        else if(target==0){
            res.push_back(record);
        }
        else{
            for(int i=index;i<candidates.size();i++){
                record.push_back(candidates[i]);
                search(candidates,target-candidates[i],record,i);
                record.pop_back();
            }
        }
    }
};
```

### 3.7 leetcode 198 打家劫舍 medium

#### tag dp 模板

#### 题目描述

```
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 

示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
 

提示：

0 <= nums.length <= 100
0 <= nums[i] <= 400
```

#### 思路

一道简单的dp，状态转移方程是dp[i]=max(dp[i-1],dp[i-2]+nums[i])

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()==0)return 0;
        if(nums.size()==1)return nums[0];
        vector<int> dp;
        dp.push_back(nums[0]);
        dp.push_back(max(nums[0],nums[1]));
        for(int i=2;i<nums.size();i++){
            dp.push_back(max(nums[i]+dp[i-2],dp[i-1]));
        }
        return dp[nums.size()-1];
    }
};
```

### 3.7 leetcode 122 买卖股票的最佳时机II easy

#### tag 贪心

#### 题目描述

```
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例 3:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
 

提示：

1 <= prices.length <= 3 * 10 ^ 4
0 <= prices[i] <= 10 ^ 4
```

#### 思路

贪心，涨了就卖

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res=0;
        int min=INT_MAX;
        for(int i=0;i<prices.size();i++){
            if(prices[i]<=min){
                min=prices[i];
            }else{
                res+=(prices[i]-min);
                min=prices[i];
            }
        }
        return res;
    }
};
```

### 3.7 leetcode 518 零钱兑换II medium

#### tag dp 模板

#### 题目描述

```
518. 零钱兑换 II
给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

 

示例 1:

输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
示例 2:

输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。
示例 3:

输入: amount = 10, coins = [10] 
输出: 1
 

注意:

你可以假设：

0 <= amount (总金额) <= 5000
1 <= coin (硬币面额) <= 5000
硬币种类不超过 500 种
结果符合 32 位符号整数
```

#### 思路

开始用了回溯，但是部分用例超时了

本题是经典的dp题

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res=0;
        int min=INT_MAX;
        for(int i=0;i<prices.size();i++){
            if(prices[i]<=min){
                min=prices[i];
            }else{
                res+=(prices[i]-min);
                min=prices[i];
            }
        }
        return res;
    }
};
```

### 3.7 leetcode 53 最大子序和 easy

#### tag dp

#### 题目描述

```
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1
示例 3：

输入：nums = [0]
输出：0
示例 4：

输入：nums = [-1]
输出：-1
示例 5：

输入：nums = [-100000]
输出：-100000
 

提示：

1 <= nums.length <= 3 * 104
-105 <= nums[i] <= 105
 

进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
```

#### 思路

dp数组用于记录以每个位置为终点的子序列和的最大值，显然dp[i]=max(nums[i],nums[i]+dp[i-1])

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int>dp;
        int res=nums[0];
        dp.push_back(nums[0]);
        for(int i=1;i<nums.size();i++){
            dp.push_back(max(nums[i],nums[i]+dp[i-1]));
            if(dp.back()>res)
                res=dp.back();
        }
        return res;
    }
};
```

### 3.7 leetcode 40 组合总和II medium

#### tag 回溯

#### 题目描述

```
给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：

所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
示例 1:

输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
示例 2:

输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
```

#### 思路

这题是组合总和的升级版，出现了重复数字，且数组中的每一项在每个组合只能用一次，最后结果还需要去重

所以这里在回溯时将index的值从i变为i+1（数组中每一项只能用一次）

去重的关键在于这一行**if(i>index && candidates[i]==candidates[i-1])continue;**（前提是已经排序好了）

尤其是这个**i>index**！！！，精髓就是在每次相同递归深度的不会重复，而不同递归深度不受影响。比如[1,1,2,5,6,7,10]中，[1,1,6]能正常产生，但不会有两个[1,7]

```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<int> record;
        sort(candidates.begin(),candidates.end());
        search(candidates,target,record,0);
        return res;
    }
    void search(vector<int>& candidates, int target,vector<int>& record,int index){
        if(target<0)return;
        else if(target==0){
            res.push_back(record);
        }
        else{
            for(int i=index;i<candidates.size();i++){
                if(i>index&&candidates[i]==candidates[i-1])continue;
                record.push_back(candidates[i]);
                search(candidates,target-candidates[i],record,i+1);
                record.pop_back();
            }
        }
    }
};
```

### 3.7 leetcode 113 路径总和II medium

#### tag DFS

#### 题目描述

```
给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

 

示例 1：


输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
示例 2：


输入：root = [1,2,3], targetSum = 5
输出：[]
示例 3：

输入：root = [1,2], targetSum = 0
输出：[]
 

提示：

树中节点总数在范围 [0, 5000] 内
-1000 <= Node.val <= 1000
-1000 <= targetSum <= 1000
```

#### 思路

DFS题目，写起来比较像回溯，这题要注意的是必须是从跟到叶节点的路径，且不可用targetSum暂时的值来判断是否介绍（可能本来就是负的）。

```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        vector<int>v;
        if(root!=NULL)
            dfs(root,v,targetSum-root->val);
        return res;
    }
    void dfs(TreeNode* root,vector<int>&v, int targetSum){
        if(targetSum==0&&root->left==NULL&&root->right==NULL){
            v.push_back(root->val);
            res.push_back(v);
            v.pop_back();
            return;
        }

        v.push_back(root->val);
        if(root->left!=NULL){
            dfs(root->left,v,targetSum-root->left->val);
        }
        if(root->right!=NULL){
            dfs(root->right,v,targetSum-root->right->val);
        }
        v.pop_back();
        return;
    }
};
```

### 3.7 leetcode 662 二叉树最大宽度 medium

#### tag BFS

#### 题目描述

```
给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。

每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。

示例 1:

输入: 

           1
         /   \
        3     2
       / \     \  
      5   3     9 

输出: 4
解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。
示例 2:

输入: 

          1
         /  
        3    
       / \       
      5   3     

输出: 2
解释: 最大值出现在树的第 3 层，宽度为 2 (5,3)。
示例 3:

输入: 

          1
         / \
        3   2 
       /        
      5      

输出: 2
解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。
示例 4:

输入: 

          1
         / \
        3   2
       /     \  
      5       9 
     /         \
    6           7
输出: 8
解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。
注意: 答案在32位有符号整数的表示范围内。
```

#### 思路

这题在bfs的基础上，为了便于计算（减小时间空间复杂度），我们需要存一下非空节点的完全二叉树数组存储方式下标（即root为1，left是2n，right是2n+1）。

```cpp
class Solution {
public:
    int widthOfBinaryTree(TreeNode* root) {
        int res=0;
        deque<TreeNode*> q;
        deque<unsigned long long> pos;
        q.push_back(root);
        pos.push_back(1);
        while(q.size()!=0){
            int size=q.size();
            unsigned long long first=-1,last=0;
            for(int i=0;i<size;i++){
                if(q.front()->left!=NULL){
                    q.push_back(q.front()->left);//2n
                    long long t1=pos.front()+pos.front();
                    pos.push_back(t1);
                }
                if(q.front()->right!=NULL){
                    q.push_back(q.front()->right);//2n+1
                    long long t2=pos.front()+pos.front()+1;
                    pos.push_back(t2);
                }
                if(first==-1)
                    first=pos.front();
                last=pos.front();    
                q.pop_front();
                pos.pop_front();
            }
            if(last-first+1>res)
                res=last-first+1;
        }
        return res;
    }

};
```

### 3.7 leetcode 300 最长递增子序列 medium

#### tag 动态规划 二分 妙

#### 题目描述

```
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

 
示例 1：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：

输入：nums = [0,1,0,3,2,3]
输出：4
示例 3：

输入：nums = [7,7,7,7,7,7,7]
输出：1
 

提示：

1 <= nums.length <= 2500
-104 <= nums[i] <= 104
 

进阶：

你可以设计时间复杂度为 O(n2) 的解决方案吗？
你能将算法的时间复杂度降低到 O(n log(n)) 吗?
```

#### 思路

这题O（n2）复杂度的解很容易想到，遍历nums，对于每一项nums[i]，寻找下标在它之前的数值比它小且dp（以其为终点的子序列长度）最大的一项，并dp+1。

O(n log(n))的解法就非常非常的精妙了，很显然这个复杂度要求需要进行二分，但是原数组是一个乱序的。这里我们想办法创造出一个有序的数组——我们运用了一个简单的贪心思路：要想递增序列最长，则应该增加的比较慢。因此，我们维护一个数组d，d[i]代表了长度为i+1的子序列集合中，末尾项最小的那个子序列的尾项值（如在1,2,4,3中有1,2,4和1,2,3两个子序列，d[2]取3而非4）。

显然d是一个递增的数组，而对于遍历过程中的每一个nums[i]，如果它比当前d的最后一项更大，那么我们在d中新增一项，值为nums[i]。

若不是，则我们需要查找它是否能更新d，即寻找d[j-1]<nums[i]<=d[j]，就更新d[j]。这里的查找过程可以使用二分法。而如果查找后发现d中没有比nums[i]小的，就更新d[0]。

最后（nums遍历一次），d的长度就是解

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> d;
        d.push_back(nums[0]);
        for(int i=1;i<nums.size();i++){
            if(nums[i]>d.back())
                d.push_back(nums[i]);
            else{
                int l=0,r=d.size()-1,m=0;
                while(l<=r){
                    m=l+(r-l)/2;
                    if(nums[i]>d[m])
                        l=m+1;
                    else
                        r=m-1;
                }
                d[l]=nums[i];
            }
        }
        return d.size();
    }
};
```

### 3.10 leetcode 88 合并两个有序数组 easy

#### tag 数组

#### 题目描述

```
给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。

 

示例 1：

输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
示例 2：

输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
 

提示：

nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-109 <= nums1[i], nums2[i] <= 109
```

#### 思路

简单的数组合并题，需要注意的是得在原地操作

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int p=0,q=0;
        int t=m;
        while(q!=n&&p!=m){
            if(nums1[p]<=nums2[q]){
                p++;
            }else{
                nums1.insert(nums1.begin()+p, nums2[q]);
                m++;
                nums1.pop_back();
                q++;
            }
        }
        if(q!=n){
            while(q!=n){
                nums1[t+n-1]=nums2[n-1];
                n--;
            }
        }
    }
};
```

### 3.11 leetcode 200 岛屿数量 medium

#### tag dfs

#### 题目描述

```
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

示例 1：

输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
示例 2：

输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
 

提示：

m == grid.length
n == grid[i].length
1 <= m, n <= 300
grid[i][j] 的值为 '0' 或 '1'
通过次数215,617提交次数408,344
```

#### 思路

这是经典的dfs题目，我们先遍历数组，找1的地方开始dfs，然后对于每个点搜索它的上下左右四个方向，对于走过的地方标记为2（防止重复计数）

```cpp
class Solution {
public:
    int res=0;
    int numIslands(vector<vector<char>>& grid) {
        int m=grid.size();
        int n=grid[0].size();
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    res++;
                }
            }
        }
        return res;
    }

    void dfs(vector<vector<char>>& grid,int i,int j){
        grid[i][j]='2';
        if(j-1>=0&&grid[i][j-1]=='1'){
            dfs(grid,i,j-1);
        }
        if(i-1>=0&&grid[i-1][j]=='1'){
            dfs(grid,i-1,j);
        }
        if(j+1<grid[0].size()&&grid[i][j+1]=='1'){
            dfs(grid,i,j+1);
        }
        if(i+1<grid.size()&&grid[i+1][j]=='1'){
            dfs(grid,i+1,j);
        }
    }
};
```

### 3.11 leetcode 110 平衡二叉树 easy

#### tag dfs

#### 题目描述

```
给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

 

示例 1：


输入：root = [3,9,20,null,null,15,7]
输出：true
示例 2：


输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
示例 3：

输入：root = []
输出：true
 

提示：

树中的节点数在范围 [0, 5000] 内
-104 <= Node.val <= 104
通过次数181,567提交次数328,057
```

#### 思路

dfs,递归地判断每个节点是不是符合条件

```cpp

class Solution {
public:
    bool res=true;
    bool isBalanced(TreeNode* root) {
        dfs(root);
        return res;
    }
    int dfs(TreeNode* root){
        if(root==NULL)return -1;
        int l=dfs(root->left)+1;
        int r=dfs(root->right)+1;
        if(l-r<-1||l-r>1)
            res=false;

        return max(l,r);
    }
};
```

### 3.11 leetcode 543 二叉树的直径 easy

#### tag dfs

#### 题目描述

```
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

 

注意：两结点之间的路径长度是以它们之间边的数目表示。
```

#### 思路

dfs,每个节点计算其左右子树的路径长度和

向上级返回的话返回左右子树中的更大的一个

```cpp
class Solution {
public:
    int res=0;
    int diameterOfBinaryTree(TreeNode* root) {
        dfs(root);
        return res;
    }
    int dfs(TreeNode* root){
        if(root==NULL)return -1;
        int l=dfs(root->left)+1;
        int r=dfs(root->right)+1;
        if(l+r>res)res=l+r;

        return max(l,r);
    }
};
```

### 3.11 leetcode 76 最小覆盖子串 hard

#### tag 滑动窗口 双指针

#### 题目描述

```
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。

 

示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
示例 2：

输入：s = "a", t = "a"
输出："a"
 

提示：

1 <= s.length, t.length <= 105
s 和 t 由英文字母组成
 

进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？
```

#### 思路

挺像最长不重复子串的，很显然是滑动窗口。我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。如何判断当前的窗口包含所有 tt 所需的字符呢？我们可以用一个哈希表表示 tt 中所有的字符以及它们的个数，用一个哈希表动态维护窗口中所有的字符以及它们的个数，如果这个动态表中包含 tt 的哈希表中的所有字符，并且对应的个数都不小于 tt 的哈希表中各个字符的个数，那么当前的窗口是「可行」的。

```cpp
class Solution {
public:
    unordered_map <char, int> ori, cnt;

    bool check() {
        for (const auto &p: ori) {
            if (cnt[p.first] < p.second) {
                return false;
            }
        }
        return true;
    }

    string minWindow(string s, string t) {
        for (const auto &c: t) {
            ++ori[c];
        }

        int l = 0, r = -1;
        int len = INT_MAX, ansL = -1, ansR = -1;

        while (r < int(s.size())) {
            if (ori.find(s[++r]) != ori.end()) {
                ++cnt[s[r]];
            }
            while (check() && l <= r) {
                if (r - l + 1 < len) {
                    len = r - l + 1;
                    ansL = l;
                }
                if (ori.find(s[l]) != ori.end()) {
                    --cnt[s[l]];
                }
                ++l;
            }
        }

        return ansL == -1 ? string() : s.substr(ansL, len);
    }
};
```

### 3.16 leetcode 142 环形链表II medium

#### tag 双指针

#### 题目描述

```
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。

说明：不允许修改给定的链表。

进阶：

你是否可以使用 O(1) 空间解决此题？
 

示例 1：



输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
示例 2：



输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
示例 3：



输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
 

提示：

链表中节点的数目范围在范围 [0, 104] 内
-105 <= Node.val <= 105
pos 的值为 -1 或者链表中的一个有效索引
```

#### 思路

判断是否有环形链表使用快慢指针，而本题我的写法是判断有圈之后，一个个节点删掉再尝试是不是还有圈，若不是就return

看了题解发现可以用数学解法

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if(!check(head))
            return NULL;
        while(head!=NULL){
            ListNode* temp=head;
            head=head->next;
            temp->next=NULL;
            if(!check(head)){
                temp->next=head;
                return temp;
            }
            temp->next=head;
        }
        return NULL;
    }

    bool check(ListNode* head){
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast!=NULL&&fast->next!=NULL){
            fast=fast->next->next;
            slow=slow->next;
            if(fast==slow)
                return true;
        }

        return false;
    }
};
```

### 3.16 leetcode 739 每日温度 medium

#### tag 栈

#### 题目描述

```
请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。
```

#### 思路

这题我想了个很朴素的方法，但是效果居然非常好。。。就逆序遍历数组，初始res放一个0，若T[i]<T[i+1]就放入1，否则根据res中对应的值依次跳跃式寻找，直到找到比i大的或者找到比i小的且res中为0

看了题解发现用的是单调栈。。

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        vector<int> res;
        res.push_back(0);
        int n=T.size();
        for(int i=n-2;i>=0;i--){
            if(T[i]<T[i+1]){
                res.push_back(1);
            }else{
                if(res.back()==0)
                    res.push_back(0);
                else{
                    int t=i+1;
                    while(T[i]>=T[t]){
                        t=t+res[n-1-t];
                        if(T[i]<T[t]){
                            res.push_back(t-i);
                            break;
                        }
                        if(t==n-1||res[n-1-t]==0){
                            res.push_back(0);
                            break;
                        }
                    }
                }
            }

        }

        reverse(res.begin(),res.end());
        return res;
    }
};
```

### 3.16 leetcode 694 不同岛屿的数量 medium

#### tag DFS hash

#### 题目描述

```
给定一个非空 01 二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的 1 组成，你可以认为网格的四周被海水包围。

请你计算这个网格中共有多少个形状不同的岛屿。两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。

 

示例 1：

11000
11000
00011
00011
给定上图，返回结果 1 。

示例 2：

11011
10000
00001
11011
给定上图，返回结果 3 。

注意：

11
1
和

 1
11
是不同的岛屿，因为我们不考虑旋转、翻转操作。

 

提示：二维数组每维的大小都不会超过 50 。
```

#### 思路

岛屿数量那题的加强版

只需要在那题的基础上把形状重复的岛（我是用vector来记录路径和执行路径时所处的level）不计入就行

```cpp
class Solution {
public:
    int res=0;
    int numDistinctIslands(vector<vector<int>>& grid) {
        int m=grid.size();
        int n=grid[0].size();
        map<int,vector<vector<int>>>mymap;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==1){
                    vector<int>t;
                    t=dfs(grid,i,j,t,0);
                    if(mymap.find(t.size())==mymap.end()){
                        res++;
                        vector<vector<int>>v;
                        v.push_back(t);
                        mymap.insert(pair<int,vector<vector<int>>>(t.size(),v));
                    }else{
                        bool check=true;
                        for(int i=0;i<mymap.at(t.size()).size();i++){
                            if(mymap.at(t.size())[i]==t){
                                check=false;
                                break;
                            }
                        }
                        if(check){
                            res++;
                            mymap.at(t.size()).push_back(t);
                        }
                    }
                    
                }
            }
        }
        return res;
    }

    vector<int> dfs(vector<vector<int>>& grid,int i,int j,vector<int>&record,int level){
        grid[i][j]=2;
        if(j-1>=0&&grid[i][j-1]==1){
            record.push_back(level);
            record.push_back(-1);
            dfs(grid,i,j-1,record,level+1);
        }
        if(i-1>=0&&grid[i-1][j]==1){
            record.push_back(level);
            record.push_back(-2);
            dfs(grid,i-1,j,record,level+1);
        }
        if(j+1<grid[0].size()&&grid[i][j+1]==1){
            record.push_back(level);
            record.push_back(-3);
            dfs(grid,i,j+1,record,level+1);
        }
        if(i+1<grid.size()&&grid[i+1][j]==1){
            record.push_back(level);
            record.push_back(-4);
            dfs(grid,i+1,j,record,level+1);
        }
        return record;
    }
};
```

### 3.16 leetcode 91 解码方法 medium

#### tag dp

#### 题目描述

```
一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> 1
'B' -> 2
...
'Z' -> 26
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"111" 可以将 "1" 中的每个 "1" 映射为 "A" ，从而得到 "AAA" ，或者可以将 "11" 和 "1"（分别为 "K" 和 "A" ）映射为 "KA" 。注意，"06" 不能映射为 "F" ，因为 "6" 和 "06" 不同。

给你一个只含数字的 非空 字符串 num ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。

 

示例 1：

输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
示例 2：

输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
示例 3：

输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
示例 4：

输入：s = "06"
输出：0
解释："06" 不能映射到 "F" ，因为字符串开头的 0 无法指向一个有效的字符。 
 

提示：

1 <= s.length <= 100
s 只包含数字，并且可能包含前导零。
```

#### 思路

用dfs会超时，所以改用dp

状态转移其实不难想，列个情况（如1 6 5 1 2 3）可知，在2出现之前，都只有两种可能16 5 1和1 6 5 1，但在2之后（因为2和前面一位可以拼接），除了继承单个字符的1 6 5 1 2和16 5 1 2，我们将12合并会有16 5 12和1 6 5 12，而合并第i和第i-1即是确定了这两位后，0~i-2直接接上这两位（就是dp[i-2]种情况），所以这时候的状态转移方程时dp[i]=dp[i-1]+dp[i-2]

但是本题主要麻烦在一堆0的边界值的考虑，不细说了

```cpp
class Solution {
public:
    int numDecodings(string s) {
        if(s[0]=='0')
        return 0;
        if(s.size()==1)
        return 1;
        //以上去除前导0
        vector<int>dp;
        dp.push_back(1);
        if((s[1]>'0'&&s[1]<='9'&&s[0]=='1')||(s[1]>'0'&&s[1]<='6'&&s[0]=='2'))
            dp.push_back(2);
        else if(s[1]=='0'&&!(s[0]=='1'||s[0]=='2'))
            return 0;
        else
            dp.push_back(1);
        for(int i=2;i<s.length();i++){
            if((s[i]>'0'&&s[i]<='9'&&s[i-1]=='1')||(s[i]>'0'&&s[i]<='6'&&s[i-1]=='2'))
                dp.push_back(dp.back()+dp.at(dp.size()-2));
            else if(s[i]=='0'&&!(s[i-1]=='1'||s[i-1]=='2'))
                return 0;
            else if(s[i]=='0')
                dp.push_back(dp.at(dp.size()-2));
            else
                dp.push_back(dp.back());
        }
        return dp.back();
    }
};
```

### 3.17 leetcode 94 二叉树的中序遍历 medium

#### tag 栈

#### 题目描述

```
给定一个二叉树的根节点 root ，返回它的 中序 遍历。

 

示例 1：


输入：root = [1,null,2,3]
输出：[1,3,2]
示例 2：

输入：root = []
输出：[]
示例 3：

输入：root = [1]
输出：[1]
示例 4：


输入：root = [1,2]
输出：[2,1]
示例 5：


输入：root = [1,null,2]
输出：[1,2]
 

提示：

树中节点数目在范围 [0, 100] 内
-100 <= Node.val <= 100
 

进阶: 递归算法很简单，你可以通过迭代算法完成吗？
```

#### 思路

用栈写，如果左边还有就一路push left，之后再访问自身-->访问right

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int>res;
        deque<TreeNode*>stack;
        TreeNode* temp=root;
        while(temp!=NULL||!stack.empty()){
            if(temp!=NULL){
                stack.push_back(temp);
                temp=temp->left;
            }else{
                temp=stack.back();
                stack.pop_back();
                res.push_back(temp->val);
                temp=temp->right;
            }
        }

        return res;
    }
};
```

### 3.17 leetcode 468 验证IP地址 medium

#### tag 正则

#### 题目描述

```
编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。

如果是有效的 IPv4 地址，返回 "IPv4" ；
如果是有效的 IPv6 地址，返回 "IPv6" ；
如果不是上述类型的 IP 地址，返回 "Neither" 。
IPv4 地址由十进制数和点来表示，每个地址包含 4 个十进制数，其范围为 0 - 255， 用(".")分割。比如，172.16.254.1；

同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。

IPv6 地址由 8 组 16 进制的数字来表示，每组表示 16 比特。这些组数字通过 (":")分割。比如,  2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。

然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。

同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的。

 

示例 1：

输入：IP = "172.16.254.1"
输出："IPv4"
解释：有效的 IPv4 地址，返回 "IPv4"
示例 2：

输入：IP = "2001:0db8:85a3:0:0:8A2E:0370:7334"
输出："IPv6"
解释：有效的 IPv6 地址，返回 "IPv6"
示例 3：

输入：IP = "256.256.256.256"
输出："Neither"
解释：既不是 IPv4 地址，又不是 IPv6 地址
示例 4：

输入：IP = "2001:0db8:85a3:0:0:8A2E:0370:7334:"
输出："Neither"
示例 5：

输入：IP = "1e1.4.5.6"
输出："Neither"
 

提示：

IP 仅由英文字母，数字，字符 '.' 和 ':' 组成。
```

#### 思路

我吐了

cpp没有split，用的py。这题的测试用例简直就是恶心人的

```cpp
class Solution:
    def validIPAddress(self, IP: str) -> str:
        if IP.count(".")!=0:
            l=IP.split(".")
            judge=True
            if len(l)!=4:
                judge=False;
            for i in l:
                if (i.__len__==0 or (i.startswith("0") and len(i)!=1) or (not i.isnumeric()) or int(i)<0 or                     int (i)>255):
                    judge=False
                    break
            if(judge):
                return "IPv4"
        if IP.count(":")!=0:
            l=IP.split(":")
            judge=True
            if len(l)!=8:
                judge=False;
            for i in l:
                i=i.lower()
                if (i.__len__==0 or len(i)>4 or not i.isalnum()):
                    judge=False
                    break
                elif max(i)>"f":
                    judge=False
                    break
            if(judge):
                return "IPv6"
        return "Neither"
```

### 3.18 leetcode 240 搜索二维矩阵II medium

#### tag 二分

#### 题目描述

```
编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
 

示例 1：


输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
示例 2：


输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
 

提示：

m == matrix.length
n == matrix[i].length
1 <= n, m <= 300
-109 <= matix[i][j] <= 109
每行的所有元素从左到右升序排列
每列的所有元素从上到下升序排列
-109 <= target <= 109
```

#### 思路

一看就是二分。。但是问题就是怎么用二分

这题是根据数据分布的特点，我们从左下角开始（大于这一列所有的，小于这一行所有的）

若小于target，那么这一行均不被考虑

若大于target，那么这一列均不被考虑

有点像dp，这题其实不用搜索的代码也能找到

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m=matrix.size();
        int n=matrix[0].size();
        int i=m-1,j=0;
        while(i>=0&&j<n){
            if(target>matrix[i][n-1])
                return false;
            if(target<matrix[0][j])
                return false;
            if(matrix[i][j]==target)
                return true;
            if(target>matrix[i][j]){
                //if(mSearch(matrix, j, n-1, i, target))
                 //   return true;
                j++;
            }else{
                //if(nSearch(matrix, 0, i, j, target))
                //    return true;
                i--;
            }
        }
        return false;
    }

    bool mSearch(vector<vector<int>>& matrix,int i,int j,int line,int target){
        int m=-1;
        while(i<=j){
            m=i+(j-i)/2;
            if(matrix[line][m]==target)return true;
            if(matrix[line][m]<target)
                i=m+1;
            else
                j=m-1; 
        }
        return false;
    }
    bool nSearch(vector<vector<int>>& matrix,int i,int j,int line,int target){
        int m=-1;
        while(i<=j){
            m=i+(j-i)/2;
            if(matrix[m][line]==target)return true;
            if(matrix[m][line]<target)
                i=m+1;
            else
                j=m-1; 
        }
        return false;
    }
};
```

### 3.19 leetcode 384 打乱数组 medium

#### tag 洗牌算法

#### 题目描述

```
给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。

实现 Solution class:

Solution(int[] nums) 使用整数数组 nums 初始化对象
int[] reset() 重设数组到它的初始状态并返回
int[] shuffle() 返回数组随机打乱后的结果
 

示例：

输入
["Solution", "shuffle", "reset", "shuffle"]
[[[1, 2, 3]], [], [], []]
输出
[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]

解释
Solution solution = new Solution([1, 2, 3]);
solution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]
solution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]
solution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]
 

提示：

1 <= nums.length <= 200
-106 <= nums[i] <= 106
nums 中的所有元素都是 唯一的
最多可以调用 5 * 104 次 reset 和 shuffle
```

#### 思路

这题是洗牌算法的模板题

为了不使用额外的空间，对于一个前n-1项已经打乱的数组，我们将第n项随机地和前面的某一项交换（也可以不换）

```cpp
class Solution {
public:
    Solution(vector<int>& nums) {
        res=nums;
        backup=nums;
    }
    
    /** Resets the array to its original configuration and return it. */
    vector<int> reset() {
        res=backup;
        return res;
    }
    
    /** Returns a random shuffling of the array. */
    vector<int> shuffle() {
        for(int i=1;i<res.size();i++){
            int m=rand()%(i+1);
            if(m!=i){
                swap(res[i],res[m]);
            }
        }
        return res;
    }
private:
    vector<int> res;
    vector<int> backup;
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(nums);
 * vector<int> param_1 = obj->reset();
 * vector<int> param_2 = obj->shuffle();
 */
```

### 3.19 leetcode 450 删除二叉搜索树中的节点 medium

#### tag 洗牌算法

#### 题目描述

```
给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。

实现 Solution class:

Solution(int[] nums) 使用整数数组 nums 初始化对象
int[] reset() 重设数组到它的初始状态并返回
int[] shuffle() 返回数组随机打乱后的结果
 

示例：

输入
["Solution", "shuffle", "reset", "shuffle"]
[[[1, 2, 3]], [], [], []]
输出
[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]

解释
Solution solution = new Solution([1, 2, 3]);
solution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]
solution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]
solution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]
 

提示：

1 <= nums.length <= 200
-106 <= nums[i] <= 106
nums 中的所有元素都是 唯一的
最多可以调用 5 * 104 次 reset 和 shuffle
```

#### 思路

算法很容易想，但是写起来很被c艹搞吐了……

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(!root) return root;
        if(key<root->val)root->left=deleteNode(root->left,key);
        if(key>root->val)root->right=deleteNode(root->right,key);
        if(key==root->val){
            if(!root->left&&!root->right)return NULL;
            if(root->left&&!root->right)return root->left;
            if(!root->left&&root->right)return root->right;
            TreeNode* temp=root->right;
            while(temp->left)temp=temp->left;
            root->val=temp->val;
            root->right=deleteNode(root->right,root->val);
        }
        return root;
    }
};
```

### 3.19 leetcode 22 括号生成 medium

#### tag 回溯

#### 题目描述

```
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

 

示例 1：

输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
示例 2：

输入：n = 1
输出：["()"]
 

提示：

1 <= n <= 8
```

#### 思路

就是回溯。。我用了left和right来判断现有的（和）的数量

```cpp
class Solution {
public:
    vector<string>res;
    vector<string> generateParenthesis(int n) {
        dfs("",n,0,0);
        return res;
    }
    void dfs(string s,int n,int left,int right){
        if(n==right&&left==n){
            res.push_back(s);
            return;
        }
        else if(left==n){
            dfs(s+")",n,left,right+1);
        }
        else{
            dfs(s+"(",n,left+1,right);
            if(left>right)
                dfs(s+")",n,left,right+1);
        }
    }
};
```

### 3.19 leetcode 151 翻转字符串里的单词 medium

#### tag 字符串

#### 题目描述

```
给定一个字符串，逐个翻转字符串中的每个单词。

说明：

无空格字符构成一个 单词 。
输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
 

示例 1：

输入："the sky is blue"
输出："blue is sky the"
示例 2：

输入："  hello world!  "
输出："world! hello"
解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
示例 3：

输入："a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
示例 4：

输入：s = "  Bob    Loves  Alice   "
输出："Alice Loves Bob"
示例 5：

输入：s = "Alice does not even like bob"
输出："bob like even not does Alice"
 

提示：

1 <= s.length <= 104
s 包含英文大小写字母、数字和空格 ' '
s 中 至少存在一个 单词
 

进阶：

请尝试使用 O(1) 额外空间复杂度的原地解法
```

#### 思路

因为要求空间O（1），所以我们不能用split（白用py了），我们选择整个翻转后再找单词依次翻转

```cpp
class Solution:
    def reverseWords(self, s: str) -> str:
        s=s.lstrip()
        s=s.rstrip()
        s=s[::-1]
        i=1
        j=1
        s=" "+s
        while(j<len(s)):
            if s[j]==" " and s[j-1]==" ":
                s=s[0:j]+s[j+1:]
                j-=1
            elif s[j]==" ":
                t=s[j-1:i-1:-1]
                s=s[0:i]+s[j-1:i-1:-1]+s[j:]
            elif s[j]!=" " and j>0 and s[j-1]==" ":
                i=j
            j+=1
        if(s[j-1]!=" "):
            s=s[0:i]+s[j:i-1:-1]
        s=s.lstrip()
        s=s.rstrip()
        return s
```

### 3.20 leetcode 89 格雷编码 medium

#### tag 位运算

#### 题目描述

```
格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。

格雷编码序列必须以 0 开头。

 

示例 1:

输入: 2
输出: [0,1,3,2]
解释:
00 - 0
01 - 1
11 - 3
10 - 2

对于给定的 n，其格雷编码序列并不唯一。
例如，[0,2,3,1] 也是一个有效的格雷编码序列。

00 - 0
10 - 2
11 - 3
01 - 1
示例 2:

输入: 0
输出: [0]
解释: 我们定义格雷编码序列必须以 0 开头。
     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。
     因此，当 n = 0 时，其格雷编码序列为 [0]。
```

#### 思路

这题得知道格雷码是怎么产生的……

以n = 2解析。
公式为 i ^ i/2 (i >> 1)
0 ^ 0 = 00 ^ 00 = 00 = 0 计算(i/2): 0/2 = 0
1 ^ 0 = 01 ^ 00 = 01 = 1 计算(i/2): 1/2 = 0
2 ^ 1 = 10 ^ 01 = 11 = 3 计算(i/2): 2/2 = 1
3 ^ 1 = 11 ^ 01 = 10 = 2 计算(i/2): 3/2 = 1

```cpp
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> ans;
        int powN = 1 << n;
        for(int i = 0; i < powN; ++i)
            ans.push_back(i^i>>1);
        return ans;
    }
};
```

### 3.20 leetcode 62 不同路径 medium

#### tag dp

#### 题目描述

```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

示例 1：


输入：m = 3, n = 7
输出：28
示例 2：

输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
示例 3：

输入：m = 7, n = 3
输出：28
示例 4：

输入：m = 3, n = 3
输出：6
 

提示：

1 <= m, n <= 100
题目数据保证答案小于等于 2 * 109
```

#### 思路

回溯应该会超时

非常经典的dp题，对于第\[i][j]项，可到达它的路径是可到达\[i-1][j]和\[i][j-1]的和

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        int paths[100][100];
        for(int i=0;i<m;i++)
            paths[i][0]=1;
        for(int i=0;i<n;i++)
            paths[0][i]=1;
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                paths[i][j]=paths[i-1][j]+paths[i][j-1];
            }
        }
        return paths[m-1][n-1];
    }
};
```

### 3.20 leetcode 138 复制带随即指针的链表 medium

#### tag hash

#### 题目描述

```
给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。

例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。

返回复制链表的头节点。

用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：

val：一个表示 Node.val 的整数。
random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。
你的代码 只 接受原链表的头节点 head 作为传入参数。

 

示例 1：



输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
示例 2：



输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
示例 3：



输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
示例 4：

输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
 

提示：

0 <= n <= 1000
-10000 <= Node.val <= 10000
Node.random 为空（null）或指向链表中的节点。
```

#### 思路

我是先利用了原有的链表的next指针指向新链表，再第二次遍历构建完成新链表后再利用hash恢复原有链表

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head==NULL)
            return NULL;
        map<Node*,Node*>map;
        Node* newhead=new Node(head->val);
        Node* res=newhead;
        while(head){
            newhead->random=head;
            Node* prev=head;
            head=head->next;
            if(head)
                newhead->next=new Node(head->val);
            else
                newhead->next=NULL;
            prev->next=newhead;
            map.insert(pair<Node*,Node*>(prev,head));
            newhead=newhead->next;
        }

        newhead=res;
        while(newhead){
            if(newhead->random!=NULL&&newhead->random->random!=NULL)
                newhead->random=newhead->random->random->next;
            else
                newhead->random=NULL;
            newhead=newhead->next;
        }

        for(auto &iter:map){
            iter.first->next=iter.second;
        }
        return res;
    }
};
```

### 3.26 leetcode 148 排序链表 medium

#### tag 归并

#### 题目描述

```
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。

进阶：

你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？
 

示例 1：


输入：head = [4,2,1,3]
输出：[1,2,3,4]
示例 2：


输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
示例 3：

输入：head = []
输出：[]
 

提示：

链表中节点的数目在范围 [0, 5 * 104] 内
-105 <= Node.val <= 105
```

#### 思路

链表排序用归并…记一下

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(head==NULL||head->next==NULL)
            return head;
        //找到middle
        ListNode* hair=new ListNode(0);
        hair->next=head;
        ListNode* fast=hair;
        ListNode* slow=hair;
        while(fast!=NULL&&fast->next!=NULL){
            fast=fast->next->next;
            slow=slow->next;
        }
        ListNode* middle=slow->next;
        slow->next=NULL;
        return merge(sortList(head),sortList(middle));
    }
    ListNode* merge(ListNode* left,ListNode* right) {
        ListNode* backup=new ListNode(0);
        ListNode* res=backup;
        while(left!=NULL&&right!=NULL){
            if(left->val<=right->val){
                res->next=left;
                left=left->next;
                res=res->next;
            }else{
                res->next=right;
                right=right->next;
                res=res->next;
            }
        }
        if(left!=NULL)
            res->next=left;
        if(right!=NULL)
            res->next=right;

        return backup->next;
    }
};
```

