---
layout:     post                    # 使用的布局（不需要改）
title:      leetcode每日一题               # 标题 
subtitle:    #副标题
date:       2020-10-18              # 时间
author:     serenity                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - leetcode
    - 算法
---

### 给今年底/明年打工面试做点准备

#### 10.18 leetcode19 删除链表的倒数第N个节点 medium

##### tag：双指针

##### 题目

```markdown
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
说明：

给定的 n 保证是有效的。

进阶：

你能尝试使用一趟扫描实现吗？
```

##### 思路

双指针，fast先走n步，这样fast到尾部时slow指向倒数第n个，注意判断下特例

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        int len=1;
        ListNode* fast=head;
        ListNode* slow=head;
        for(int i=0;i<n-1;i++){
            fast=fast->next;
        }
        if(fast->next==nullptr&&fast==head){
            return nullptr;
        }
        else if(fast->next==nullptr){
            fast=head->next;
            head->next=nullptr;
            return fast;
        }
        fast=fast->next;
        while(fast->next!=nullptr){
            slow=slow->next;
            fast=fast->next;
        }
        slow->next=slow->next->next;
        return head;
    }
};
```



#### 10.20 leetcode143 重排链表 medium

##### tag：双指针 链表反转

##### 题目

```markdown
给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:

给定链表 1->2->3->4, 重新排列为 1->4->2->3.
示例 2:

给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3
```

##### 思路

先用双指针确定中点（fast速度是slow两倍），再分成两个链表后将后一半反转，两个链表再依次取值

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
 //双指针
class Solution {
public:
    void reorderList(ListNode* head) {
        if(head==nullptr||head->next==nullptr)
            return ;
        ListNode* fast=head;
        ListNode* slow=head;
        //fast速度为slow两倍,slow定位至middle
        while(!(fast->next==nullptr||fast->next->next==nullptr)){
            fast=fast->next->next;
            slow=slow->next;
        }
        fast=head;//存return
        ListNode* middle=slow->next;
        slow->next=nullptr;
        ListNode* temp=nullptr;
        middle=reverse(middle);
        while(head!=nullptr&&middle!=nullptr){
            temp=middle->next;
            middle->next=head->next;
            head->next=middle;
            head=middle->next;
            middle=temp;
        }
        return ;
    }
    ListNode* reverse(ListNode* head){
        ListNode *p1 = NULL;
        ListNode *p2 = head;
        ListNode *p3 = p2;
        
        while(p2){
            p3 = p2->next;
            p2->next = p1;
            p1 = p2;
            p2 = p3;            
        }
        return p1;
    }
};
```

##### 其他思路

不反转后半段，而是使用栈来处理



#### 10.21 leetcode925 长按键入 easy

##### tag：双指针 字符串

##### 题目

```markdown
你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。

你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。

 

示例 1：

输入：name = "alex", typed = "aaleex"
输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。
示例 2：

输入：name = "saeed", typed = "ssaaedd"
输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。
示例 3：

输入：name = "leelee", typed = "lleeelee"
输出：true
示例 4：

输入：name = "laiden", typed = "laiden"
输出：true
解释：长按名字中的字符并不是必要的。
 

提示：

name.length <= 1000
typed.length <= 1000
name 和 typed 的字符都是小写字母。
 
```

##### 思路

双指针对应typed和name，typed的每一个char要么匹配name中的一个char，要么和typed前一个相同，否则即为false

```cpp
class Solution {
public:
    bool isLongPressedName(string name, string typed) {
        int i = 0, j = 0;
        while (j < typed.length()) {
            if (i < name.length() && name[i] == typed[j]) {
                i++;
                j++;
            } else if (j > 0 && typed[j] == typed[j - 1]) {
                j++;
            } else {
                return false;
            }
        }
        return i == name.length();
    }
};
```

