---
layout:     post                    # 使用的布局（不需要改）
title:      leetcode每日一题               # 标题 
subtitle:    #副标题
date:       2020-10-18              # 时间
author:     serenity                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - leetcode
    - 算法
---

## 给今年底/明年打工面试做点准备

### 10.18 leetcode19 删除链表的倒数第N个节点 medium

#### tag：双指针

#### 题目

```markdown
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
说明：

给定的 n 保证是有效的。

进阶：

你能尝试使用一趟扫描实现吗？
```

#### 思路

双指针，fast先走n步，这样fast到尾部时slow指向倒数第n个，注意判断下特例

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        int len=1;
        ListNode* fast=head;
        ListNode* slow=head;
        for(int i=0;i<n-1;i++){
            fast=fast->next;
        }
        if(fast->next==nullptr&&fast==head){
            return nullptr;
        }
        else if(fast->next==nullptr){
            fast=head->next;
            head->next=nullptr;
            return fast;
        }
        fast=fast->next;
        while(fast->next!=nullptr){
            slow=slow->next;
            fast=fast->next;
        }
        slow->next=slow->next->next;
        return head;
    }
};
```



### 10.20 leetcode143 重排链表 medium

#### tag：双指针 链表反转

#### 题目

```markdown
给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:

给定链表 1->2->3->4, 重新排列为 1->4->2->3.
示例 2:

给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3
```

#### 思路

先用双指针确定中点（fast速度是slow两倍），再分成两个链表后将后一半反转，两个链表再依次取值

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
 //双指针
class Solution {
public:
    void reorderList(ListNode* head) {
        if(head==nullptr||head->next==nullptr)
            return ;
        ListNode* fast=head;
        ListNode* slow=head;
        //fast速度为slow两倍,slow定位至middle
        while(!(fast->next==nullptr||fast->next->next==nullptr)){
            fast=fast->next->next;
            slow=slow->next;
        }
        fast=head;//存return
        ListNode* middle=slow->next;
        slow->next=nullptr;
        ListNode* temp=nullptr;
        middle=reverse(middle);
        while(head!=nullptr&&middle!=nullptr){
            temp=middle->next;
            middle->next=head->next;
            head->next=middle;
            head=middle->next;
            middle=temp;
        }
        return ;
    }
    ListNode* reverse(ListNode* head){
        ListNode *p1 = NULL;
        ListNode *p2 = head;
        ListNode *p3 = p2;
        
        while(p2){
            p3 = p2->next;
            p2->next = p1;
            p1 = p2;
            p2 = p3;            
        }
        return p1;
    }
};
```

#### 其他思路

不反转后半段，而是使用栈来处理



### 10.21 leetcode925 长按键入 easy

#### tag：双指针 字符串

#### 题目

```markdown
你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。

你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。

 

示例 1：

输入：name = "alex", typed = "aaleex"
输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。
示例 2：

输入：name = "saeed", typed = "ssaaedd"
输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。
示例 3：

输入：name = "leelee", typed = "lleeelee"
输出：true
示例 4：

输入：name = "laiden", typed = "laiden"
输出：true
解释：长按名字中的字符并不是必要的。
 

提示：

name.length <= 1000
typed.length <= 1000
name 和 typed 的字符都是小写字母。
 
```

#### 思路

双指针对应typed和name，typed的每一个char要么匹配name中的一个char，要么和typed前一个相同，否则即为false

```cpp
class Solution {
public:
    bool isLongPressedName(string name, string typed) {
        int i = 0, j = 0;
        while (j < typed.length()) {
            if (i < name.length() && name[i] == typed[j]) {
                i++;
                j++;
            } else if (j > 0 && typed[j] == typed[j - 1]) {
                j++;
            } else {
                return false;
            }
        }
        return i == name.length();
    }
};
```



### 10.22 leetcode763 划分字母区间 medium

#### tag：哈希 贪心

#### 题目

```markdown
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。

 

示例 1：

输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
 

提示：

S的长度在[1, 500]之间。
S只包含小写字母 'a' 到 'z' 。
 
```

#### 思路

先遍历一遍记录所有字母的最后出现的位置（end），使用hash（map）存储。在进行指针遍历时，使用segend记录当前段的终点（每一次前进先更新segend，为max（segend,map[S[I]]）），当i=segend时即即为一个段。

```cpp
class Solution {
public:
    vector<int> partitionLabels(string S) {
        vector<int> res;
        unordered_map<char, int> map;
        for(int i=0;i<S.length();i++){
            map[S[i]]=i;
        }//遍历记录每个字母end
        int segend=map[S[0]];
        int rec=0;
        for(int i=0;i<S.length();i++){
            if(map[S[i]]>segend){
                segend=map[S[i]];
            }
            if(i==segend){
                segend=0;
                res.push_back(i-rec+1);
                rec=i+1;
            }
        }
        if(res.size()==0)
            res.push_back(S.length());
        return res;

    }
};
```



### 10.23 leetcode234 回文链表 easy

#### tag：快慢指针

#### 题目

```markdown
请判断一个链表是否为回文链表。

示例 1:

输入: 1->2
输出: false
示例 2:

输入: 1->2->2->1
输出: true
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
 
```

#### 思路

类似10.20的重排链表那题。先用快慢指针（fast为两倍速）确定中点，后半段反转后再和前半段一一对比。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* fast=head;
        ListNode* slow=head;
        if(fast==nullptr)
            return true;
        while(fast->next!=nullptr&&fast->next->next!=nullptr){
            fast=fast->next->next;
            slow=slow->next;
        }
        ListNode* middle=reverse(slow->next);
        while(head!=nullptr&&middle!=nullptr){
            if(head->val!=middle->val)
                return false;
            head=head->next;
            middle=middle->next;
        }
        return true;
    }
    ListNode* reverse(ListNode* head){
        ListNode *p1 = NULL;
        ListNode *p2 = head;
        ListNode *p3 = p2;
        
        while(p2){
            p3 = p2->next;
            p2->next = p1;
            p1 = p2;
            p2 = p3;            
        }
        return p1;
    }
};
```





### 11.9 leetcode973 最接近原点的K个点 medium

#### tag：堆 队列 hash/快排

#### 题目

```markdown
我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。

（这里，平面上两点之间的距离是欧几里德距离。）

你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。

 

示例 1：

输入：points = [[1,3],[-2,2]], K = 1
输出：[[-2,2]]
解释： 
(1, 3) 和原点之间的距离为 sqrt(10)，
(-2, 2) 和原点之间的距离为 sqrt(8)，
由于 sqrt(8) < sqrt(10)，(-2, 2) 离原点更近。
我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。
示例 2：

输入：points = [[3,3],[5,-1],[-2,4]], K = 2
输出：[[3,3],[-2,4]]
（答案 [[-2,4],[3,3]] 也会被接受。）
```

#### 思路

一开始想通过维护一个大小为k的队列，并用hash减少平方值运算次数，对队列内插入时进行排序，但超时了 【时间复杂度O（nk）】

修改后使用大顶堆维护队列,（cpp的优先队列默认是一个大顶堆）【时间复杂度O（nlogk）】

```cpp
//初始解法
class Solution {
public:
    bool compare(vector<int> a,vector<int> b){
        return (a.at(0)*a.at(0)+a.at(1)*a.at(1))<(b.at(0)*b.at(0)+b.at(1)*b.at(1));
    }
    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {
        vector<pair<int, vector<int>>> res;
        for(int i=0;i<points.size();i++){
            int x=points[i][0],y=points[i][1];
            pair<int,vector<int>> p(x*x+y*y,points[i]);
            if(res.size()>=K){
                if(p.first<res.at(K-1).first){
                    res.pop_back();
                }
                else
                    continue;
            }
                int pos=0;
                if(res.size()==0){
                    res.push_back(p);
                    continue;
                }
                while(pos<res.size()){
                    if(p.first<res.at(pos).first){
                        vector<pair<int, vector<int>>>::iterator iter=res.begin()+pos;
                        res.insert(iter,p);
                        break;
                    }
                    pos++;
                }
                if(pos==res.size())
                    res.push_back(p);
            }
            vector<vector<int>> result(K);
            for (int i = 0; i < K; i++) {
                result[i] = res[i].second;
            }
            return result;
        }

};
//使用大顶堆
class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {
        priority_queue<pair<int, vector<int>>, vector<pair<int, vector<int>>>> res;
        for(int i=0;i<points.size();i++){
            int x=points[i][0],y=points[i][1];
            pair<int,vector<int>> p(x*x+y*y,points[i]);
            res.push(p);
            if(res.size()>K){
                res.pop();
            }
        }
            vector<vector<int>> result(K); // 把队列里元素放入数组
            for (int i = 0; i < K; i++) {
                result[i] = res.top().second;
                res.pop();
            }
            return result;
        }

};
```



### 11.10 leetcode31 下一个排列 medium

#### tag：数组

#### 题目

```markdown
实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

示例 1：

输入：nums = [1,2,3]
输出：[1,3,2]
示例 2：

输入：nums = [3,2,1]
输出：[1,2,3]
示例 3：

输入：nums = [1,1,5]
输出：[1,5,1]
示例 4：

输入：nums = [1]
输出：[1]
 

提示：

1 <= nums.length <= 100
0 <= nums[i] <= 100
```

#### 思路

从后向前遍历，若出现nums[i]>nums[i-1],则说明存在更大的字典排序，取i-1之后的比nums[i-1]大的数字中最小的一个与nums[i-1]交换，再从小到大排序nums[i]及之后的。若始终没有nums[i]>nums[i-1],则已经是字典序最大的情况，则直接整个进行排序

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        bool biggest=true;
        for(int i=nums.size()-1;i>0;i--){
            if(nums.at(i)>nums.at(i-1)){
                int swap=i;
                int temp=0;
                for(int j=i;j<nums.size();j++){
                    if(nums.at(j)<nums.at(swap)&&nums.at(j)>nums.at(i-1))
                        swap=j;    
                }
                temp=nums.at(i-1);
                nums.at(i-1)=nums.at(swap);
                nums.at(swap)=temp;
                sort(nums,i);
                biggest=false;
                break;
            }
        }
        if(biggest)
            sort(nums,0);
    
    }
    void sort(vector<int>& nums,int start){
        for(int i=start;i<nums.size()-1;i++){
            int min=i;
            int temp=0;
            for(int j=i+1;j<nums.size();j++){
                if(nums.at(j)<nums.at(min))
                    min=j;
            }
            temp=nums.at(i);
            nums.at(i)=nums.at(min);
            nums.at(min)=temp;
        }
    }
};
```



### 11.12 leetcode922 按奇偶排序数组II easy

#### tag：数组

#### 题目

```markdown
给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。

对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。

你可以返回任何满足上述条件的数组作为答案。

 

示例：

输入：[4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
 

提示：

2 <= A.length <= 20000
A.length % 2 == 0
0 <= A[i] <= 100
 
```

#### 思路

i：easy，两个向量扫描一遍，当同时出现奇数&偶数不配对的情况时，swap

ii：还可以考虑空间换时间，再开一个res数组，依次往里面填，免去交换过程

```cpp
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& A) {
        int i=0,j=1;
        int temp=0;
        while(i<A.size()&&j<A.size()){
            if(A.at(i)%2!=0&&A.at(j)!=1){
                temp=A.at(i);
                A.at(i)=A.at(j);
                A.at(j)=temp;
            }
            if(A.at(i)%2==0)
                i+=2;
            if(A.at(j)%2==1)
                j+=2; 
        }
        return A;
    }
};
```



### 11.13 leetcode328 奇偶链表 medium

#### tag：双指针+固定指针

#### 题目

```markdown
给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

示例 1:

输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
示例 2:

输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
说明:

应当保持奇数节点和偶数节点的相对顺序。
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。
 
```

#### 思路

感觉挺简单的，一个指针指向奇数，一个指向偶数，交替更换next，最后奇数指针指向固定的偶数开头

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        ListNode* slow=head;
        if(head==nullptr||head->next==nullptr)
            return head;
        ListNode* fast=head->next;
        ListNode* sec=fast;
        while(fast!=nullptr&&fast->next!=nullptr){
            slow->next=fast->next;
            slow=slow->next;
            fast->next=slow->next;
            fast=fast->next;
        }
        slow->next=sec;
        if (fast!=nullptr)
            fast->next=nullptr;
        return head;
    }
};
```



### 1.27 leetcode25 K个一组翻转链表 hard

#### tag 链表 模拟 高频

#### 题目

```
给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

 

示例：

给你这个链表：1->2->3->4->5

当 k = 2 时，应当返回: 2->1->4->3->5

当 k = 3 时，应当返回: 3->2->1->4->5

 

说明：

你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
```

#### 思路

本题思路非常清晰，即通过快慢指针依次确定若干组k个节点进行翻转（*链表翻转见leetcode206*），需要注意的是，本题的困难点在于**一个局部链表翻转前后的连接**。

以1->2->3->4->5，k=2时为例

比如翻转3,4时需要将3，4前后先断开，变为1->2  3->4  5，翻转后再连接上，变为1->2->4->3->5

这就要求我们记录原来链表中**3的前一个结点**（代码中的hair）和**4的后一个节点**（代码中的temp），为了使得第一组k个元素也可以这样操作（同时保证了最终结果的返回值固定为pre->next），我们在链表最前方添加一个节点pre，即变为pre->1->2->3->4->5

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* pre=new ListNode(0,head);
        ListNode* fast=pre;
        ListNode* hair=pre;
        ListNode* temp=nullptr;
        while(1){
            for(int i=0;i<k;i++){
                fast=fast->next;
                if(fast==nullptr)
                    return pre->next;//返回值，最终结果
            }
            temp=fast->next;//temp用来保存断开连接前的后继节点
            fast->next=nullptr;
            hair->next=reverse(head);
            fast=head;//此时head已经从局部链表头部变为尾部
            fast->next=temp;//重新连接链表
            hair=fast;
            head=temp;
        }
        
    }

    ListNode* reverse(ListNode* head){
        ListNode* before=nullptr;
        ListNode* after=nullptr;
        ListNode* tail=head;
        while(head!=nullptr){
            after=head->next;
            head->next=before;
            before=head;
            head=after;
        }
        return before;
    }
};
```

### 1.27 leetcode 3 无重复字符的最长子串 medium

#### tag 滑动窗口

#### 题目

```
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

 

示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
示例 4:

输入: s = ""
```

#### 思路

用滑动窗口解决，使用一个hashmap记录存在的字符，当right的字符已经存在时，更新left位置和hashmap

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.length()==0) return 0;
        int left=0,right=0,len=1,res=1;
        map<char,int> mymap;
        mymap.insert(pair<char,int>(s[0],0));
        while(1){
            if(right<s.length()-1) right++;
            else return res;
            if(mymap.find(s[right])==mymap.end()){
                len++;
                mymap.insert(pair<char,int>(s[right],right))
            }else {
				int temp = mymap[s[right]] + 1;
				for (int i = left; i < mymap[s[right]]; i++) {
					mymap.erase(s[i]);
				}
                //很奇怪，这里循环中如果将原先重复字符的map记录也删掉的话，跳出循环后该记录又会自动加上
				mymap[s[right]] = right;
				left = temp;
				len = right - left + 1;
			}
            if(len>res) res=len;
        }
    }
};
```



### 1.29 leetcode 15 三数之和 medium

#### tag 双指针

#### 题目描述

```
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

 

示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
示例 2：

输入：nums = []
输出：[]
示例 3：

输入：nums = [0]
输出：[]
 

提示：

0 <= nums.length <= 3000
-10^5 <= nums[i] <= 10^5
```

#### 思路

暴力解法的时间复杂度为O（N^3），我们对此进行的优化为先进行排序，再根据确定的第一个指针来判断此情况下p2和p3可能的取值，由于需要a+b+c=0，a确定的情况下，b越大则c越小，所以我们使用双指针方法，b从p1+1位置开始向后遍历，c从尾部向前遍历，相遇则对于这个a的值结束。

另外一个需要注意的点是元组不可相同，因此我们遇到和先前一个值相同的情况直接跳过（这也是为什么我们锚定p1而不是p2，因为对于-4，-1，-1，0，1，2这样的情况而言，锚定p1时p2，p3的取值情况会被后续完整包括，，而如果锚定p2则不能，如上述例子中，锚定p2的话，如果也采用相同就跳过的方式，则会漏掉-1，-1，2的组合）

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
       vector<vector<int>> res;
		if (nums.size() < 3) return res;
		sort(nums.begin(), nums.end());
		int p1 = 0, p3 = nums.size() - 1, p2,sum;
		for (p1 = 0; p1 < nums.size()-2; p1++) {
			p2 = p1+1, p3 = nums.size() - 1;
			if (p1 != 0 && nums[p1] == nums[p1 - 1]) continue;
			while (p2 != p3) {
				sum = nums[p1] + nums[p2] + nums[p3];
				if (sum == 0) {
					vector<int> rec = { nums[p1], nums[p2], nums[p3] };
					res.push_back(rec);
					if (p2 < p3) {
						p2++;
						while (nums[p2] == nums[p2 - 1] && p2 < p3) p2++;
					}
					else { break; }
				}
				else if (sum < 0) {
					p2++;
					while (nums[p2] == nums[p2 - 1]&&p2<p3) p2++;
				}
				else {
					p3--;
					while (nums[p3] == nums[p3 + 1] && p3 > p2) p3--;
				}
			}
		}
		return res;
        
    }
};
```

### 3.1 leetcode 103 二叉树的锯齿形层序遍历 medium

#### tag BFS

#### 题目描述

```
给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层序遍历如下：

[
  [3],
  [20,9],
  [15,7]
]
```

#### 思路

一开始想的是BFS+对每一层交替使用栈和队列，后来发现不用这么麻烦，bfs的时候对于一层的结果暂存时进行一下判断，若是需要逆转就reverse后再加入res中。

这题需要注意的是，bfs过程中如何按层存储（在开始每一层的遍历前先记录下当前队列的大小）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<int>t;
        queue<TreeNode*> store;
        bool rev=false;
        vector<vector<int>> res;
        store.push(root);
        while(store.size()!=0){
            int count=store.size();
            for(int i=0;i<count;i++){
                root=store.front();
                store.pop();
                if(root!=NULL){
                    t.push_back(root->val);
                    store.push(root->left);
                    store.push(root->right);
                }
            }
            if(rev){
                reverse(t.begin(),t.end());
            }
            if(t.size()!=0)
                res.push_back(t);
            t.clear();
            rev=!rev;
        }
        return res;
    }
};
```

### 3.1 leetcode 121 买卖股票的最佳时机 medium

#### tag 动态规划

#### 题目描述

```
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

 

示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 

提示：

1 <= prices.length <= 105
0 <= prices[i] <= 104
```

#### 思路

一次遍历，p为指针，同时用mins记录p之前的最小值

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res=0;
        int p=0,mins=prices[0];
        while(p<prices.size()){
            mins=min(prices[p],mins);
            res=max(res,prices[p]-mins);
            p++;
        }

        return res;
    }
};
```

### 3.4 leetcode 146 LRU缓存机制 medium

#### tag 双向链表 hash

#### 题目描述

```
运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。
实现 LRUCache 类：

LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。
 

进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？

 

示例：

输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

#### 思路

由于要求在O(1)内完成，很显然要用hash的来存取。但是hash无法实现有序存储（即根据访问时间进行lru），这里又需要我们用一个list或者vector来存储，但vector这里数组的删除复杂度为O(N)，因此我们选用双向链表（双向是为了便于添加删除），链表的节点存储key和val（链表也存储key是为了便于在map中删除时根据head节点获取要删除的key）。

另一个trick是使用链表时，为了减少边界情况的if判断，可以使用一个head和tail节点

```cpp
struct Node {
	int key, val;
	Node *prev;
	Node *next;
	Node(int key, int x) :key(key), val(x), prev(NULL), next(NULL) {}
};

class LRUCache {
public:
	LRUCache(int capacity) {
		cap = capacity;
	}

	int get(int key) {
		if (m.find(key) != m.end()) {
			p = m.at(key);
			p->prev->next = p->next;
			p->next->prev = p->prev;

			p->next = tail;
			p->prev = tail->prev;
			tail->prev->next = p;
			tail->prev = p;

			return m.at(key)->val;
		}
		else {
			return -1;
		}
	}

	void put(int key, int value) {
		if (m.size() == 0) {
			p = new Node(key, value);
			m.insert(pair<int, Node*>(key, p));
			head = new Node(-1, -1);;
			tail = new Node(-1, -1);;
			head->next =p; 
			tail->prev = p;
            p->next=tail;
            p->prev=head;
		}
		else if( m.find(key) != m.end()) {
            //将其移动至链表尾部并修改value
				p = m.at(key);
				p->val = value;
				p->prev->next = p->next;
				p->next->prev = p->prev;

				p->next = tail;
				p->prev = tail->prev;
				tail->prev->next = p;
				tail->prev = p;
			}
            else{
                if (m.size() < cap) {
                    p = new Node(key, value);
                    p->next = tail;
                    p->prev = tail->prev;
                    tail->prev->next = p;
                    tail->prev = p;
                    m.insert(pair<int, Node*>(key, p));
                }
		else {
			//删除头部节点,插入新node至尾部
			p = new Node(key, value);
			m.erase(head->next->key);
			head->next->next->prev = head;
			head->next = head->next->next;
			p->next = tail;
			p->prev = tail->prev;
			tail->prev->next = p;
			tail->prev = p;
			m.insert(pair<int, Node*>(key, p));
		}
        }
	}
private:
	int cap;
	Node* head = nullptr;
	Node* tail = nullptr;
	Node* p = nullptr;
	vector<int> cache;
	unordered_map<int, Node*> m;

};
/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

### 3.4 leetcode 105 从前序和中序构建二叉树 medium

#### tag 树 递归

#### 题目描述

```
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7

```

#### 思路

递归题，模拟大脑内构建这棵二叉树的过程

先获取前序中的[0]作为root，在中序中定位后，中序[index]左侧为左子树，右侧为右子树，递归。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size()==0){
            return NULL;
        }else{
            TreeNode* root=new TreeNode(preorder[0]);
            vector<int>::iterator result=find(inorder.begin(),inorder.end(),preorder[0]             );
            int index=distance(inorder.begin(), result);
            vector<int>a(preorder.begin()+1,preorder.begin()+1+index);
            vector<int>b(inorder.begin(),inorder.begin()+index);
            root->left=buildTree(a,b);
            vector<int>c(preorder.begin()+1+index,preorder.end());
            vector<int>d(inorder.begin()+index+1,inorder.end());
            root->right=buildTree(c,d);
            return root;
        }   
    }
};
```

### 3.4 leetcode 199 二叉树的右视图 medium

#### tag BFS

#### 题目描述

```
给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---

```

#### 思路

和lc103 二叉树锯齿状遍历很像

这题需要注意的是，bfs过程中如何按层存储（在开始每一层的遍历前先记录下当前队列的大小）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int>res;
        queue<TreeNode*> q;
        q.push(root);
        if(root==NULL||q.size()==0)
            return res;
        while(q.size()>0){
            int size=q.size();
            for(int i=0;i<size;i++){
                TreeNode* temp=q.front();
                q.pop();
                if(i==size-1){
                    res.push_back(temp->val);
                }
                if(temp->left!=NULL)
                    q.push(temp->left);
                if(temp->right!=NULL)
                    q.push(temp->right);
            }
        }
        return res;
    }
};
```

### 3.4 leetcode 160 相交链表 easy

#### tag 脑筋急转弯

#### 题目描述

```
编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表：



在节点 c1 开始相交。

 

示例 1：



输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
 

示例 2：



输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
 

示例 3：



输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
 

注意：

如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

```

#### 思路

脑筋急转弯题目。。。不知道为啥喜欢考这种

思路是两个链表相加的总长度是一定的，因此两个指针分别从A、B出发，以A->B和B->A两条路径，如果是有交点的，则必然在路径上某点相遇（交点），否则不会相遇。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *p1=headA;
        ListNode *p2=headB;
        int a=0,b=0;
        if(p1!=NULL&&p2!=NULL){
        while(a<2&&b<2){
            if(p1==NULL){
                p1=headB;
                a++;
            }
            if(p2==NULL){
                p2=headA;
                b++;
            }
            if(p1==p2)
                return p1;
            p1=p1->next;
            p2=p2->next;
        }
        }
        return NULL;
    }
};
```

### 3.4 leetcode 54 螺旋矩阵 medium

#### tag 模拟

#### 题目描述

```
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

示例:

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]

```

#### 思路

直接暴力模拟，很像大一的那种题目

标记一下矩阵内已经访问过的地方，根据direction变量来判断移动方位。边界情况下改变移动方向。

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        const int no=-999;
        int m=matrix.size();
        int n=matrix[0].size();
        int direction=0;//0右 1下 2左 3上
        for(int i=0,j=0,count=0;count<m*n;count++){
            res.push_back(matrix[i][j]);
            matrix[i][j]=no;
            switch(direction){
                case 0:
                    if(j==n-1||matrix[i][j+1]==no){
                        direction=1;
                        i++;
                    }
                    else
                        j++;
                    break;
                case 1:
                    if(i==m-1||matrix[i+1][j]==no){
                        direction=2;
                        j--;
                    }
                    else
                        i++;
                    break;
                case 2:
                    if(j==0||matrix[i][j-1]==no){
                        direction=3;
                        i--;
                    }
                    else
                        j--;
                    break;
                case 3:
                    if(i==0||matrix[i-1][j]==no){
                        direction=0;
                        j++;
                    }
                    else
                        i--;
                    break;  
            }
            
        }

        return res;
    }

};
```

### 3.4 leetcode 21 合并两个有序链表 easy

#### tag 链表

#### 题目描述

```
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

示例 1：


输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
示例 2：

输入：l1 = [], l2 = []
输出：[]
示例 3：

输入：l1 = [], l2 = [0]
输出：[0]

提示：
两个链表的节点数目范围是 [0, 50]
-100 <= Node.val <= 100
l1 和 l2 均按 非递减顺序排列
```

#### 思路

简单题……直接加

注意用一下伪头部，减少if判断

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* l=new ListNode(0);
        ListNode* backup=l;
        while(l1!=nullptr&&l2!=nullptr){
            if(l1->val<=l2->val){
                l->next=l1;
                l1=l1->next;
                l=l->next;
            }else{
                l->next=l2;
                l2=l2->next;
                l=l->next;
            }
        }
        if(l1==nullptr){
            l->next=l2;
        }else{
            l->next=l1;
        }

        return backup->next;
    }
};
```

